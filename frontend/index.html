<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RAYCISM ENGINE</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-0: #060606;
      --bg-1: #0c0c0c;
      --bg-2: #111111;
      --bg-3: #181818;
      --line: #262626;
      --line-strong: #3a3a3a;
      --text-0: #f5f5f5;
      --text-1: #bdbdbd;
      --text-2: #8a8a8a;
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --radius: 1px;
      --font-sans: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
      --font-mono: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
      --ease: 160ms ease;
      --accent-running: #38bf6b;
      --accent-warn: #e0af45;
      --accent-error: #e16262;
      --accent-focus: #67a9ff;
      --accent-gpu: #7ebeff;
      --accent-selection: #6ea6ff;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
      background: var(--bg-0);
    }

    body {
      font-family: var(--font-sans);
      font-size: 12px;
      line-height: 1.4;
      color: var(--text-0);
      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
    }

    .app {
      height: 100%;
      display: flex;
      flex-direction: column;
      background: var(--bg-0);
      color: var(--text-0);
    }

    .error-banner {
      display: none;
      padding: 6px 12px;
      border-bottom: 1px solid var(--line-strong);
      border-left: 2px solid var(--accent-error);
      background: var(--bg-2);
      color: var(--text-0);
      font-family: var(--font-mono);
      letter-spacing: 0.01em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .error-banner.visible {
      display: block;
    }

    .gpu-banner {
      display: none;
      padding: 6px 12px;
      border-bottom: 1px solid var(--line);
      border-left: 2px solid var(--accent-warn);
      background: var(--bg-1);
      color: var(--text-1);
      font-family: var(--font-mono);
      letter-spacing: 0.01em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .gpu-banner.visible {
      display: block;
    }

    .topbar {
      position: relative;
      height: 42px;
      border-bottom: 1px solid var(--line);
      background: var(--bg-1);
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: var(--space-3);
      padding: 0 var(--space-3);
      flex-shrink: 0;
    }

    .topbar::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: -1px;
      height: 2px;
      background: transparent;
      transition: background var(--ease);
      pointer-events: none;
    }

    .app.state-running .topbar::after {
      background: var(--accent-running);
    }

    .app.state-warn .topbar::after {
      background: var(--accent-warn);
    }

    .app.state-error .topbar::after {
      background: var(--accent-error);
    }

    .topbar-left,
    .topbar-center,
    .topbar-right {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      min-width: 0;
    }

    .topbar-center {
      justify-content: center;
      overflow: hidden;
    }

    .top-demo-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
    }

    .top-inline-label {
      color: var(--text-2);
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .top-select {
      height: 28px;
      min-width: 118px;
      border: 1px solid var(--line);
      background: var(--bg-0);
      color: var(--text-0);
      border-radius: var(--radius);
      font-family: var(--font-sans);
      font-size: 11px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 0 8px;
      outline: none;
    }

    .top-select:hover {
      border-color: var(--line-strong);
    }

    .top-select:focus {
      border-color: var(--accent-focus);
    }

    .brand {
      display: inline-flex;
      align-items: center;
      gap: 0;
      min-width: 0;
      padding-right: var(--space-2);
    }

    .brand-text {
      font-size: 11px;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      font-weight: 300;
      color: var(--text-0);
      white-space: nowrap;
    }

    .status-item {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      min-height: 26px;
      padding: 0 10px;
      border: 1px solid var(--line);
      background: var(--bg-2);
      font-size: 11px;
      color: var(--text-1);
      white-space: nowrap;
      transition: color var(--ease), border-color var(--ease);
    }

    .status-state::before {
      content: "";
      width: 2px;
      align-self: stretch;
      background: var(--line-strong);
      margin-left: -10px;
      margin-right: 8px;
      transition: background var(--ease);
    }

    .app.state-running .status-state::before {
      background: var(--accent-running);
    }

    .app.state-warn .status-state::before {
      background: var(--accent-warn);
    }

    .app.state-error .status-state::before {
      background: var(--accent-error);
    }

    .status-item strong {
      font-family: var(--font-mono);
      font-weight: 500;
      color: var(--text-0);
      letter-spacing: 0.01em;
    }

    .state-dot {
      width: 7px;
      height: 7px;
      border: 1px solid var(--text-2);
      background: transparent;
      display: inline-block;
      flex-shrink: 0;
      transition: opacity var(--ease), border-color var(--ease), background var(--ease);
    }

    .state-dot.running {
      background: var(--accent-running);
      border-color: var(--accent-running);
      animation: dot-pulse 1.2s steps(2, end) infinite;
    }

    .state-dot.warn {
      background: var(--accent-warn);
      border-color: var(--accent-warn);
      animation: dot-pulse 1.8s steps(2, end) infinite;
    }

    .state-dot.error {
      background: var(--accent-error);
      border-color: var(--accent-error);
      animation: dot-pulse 900ms steps(2, end) infinite;
    }

    #stateText.state-running {
      color: var(--accent-running);
    }

    #stateText.state-warn {
      color: var(--accent-warn);
    }

    #stateText.state-error {
      color: var(--accent-error);
    }

    #backendText.backend-gpu {
      color: var(--accent-gpu);
    }

    @keyframes dot-pulse {
      0%,
      100% { opacity: 1; }
      50% { opacity: 0.35; }
    }

    .btn,
    .icon-btn {
      height: 28px;
      border: 1px solid var(--line);
      background: transparent;
      color: var(--text-1);
      border-radius: var(--radius);
      font-family: var(--font-sans);
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      padding: 0 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      transition: background var(--ease), border-color var(--ease), opacity var(--ease);
      white-space: nowrap;
    }

    .icon-btn {
      width: 28px;
      padding: 0;
      font-size: 10px;
      letter-spacing: 0;
    }

    .btn:hover:not(:disabled),
    .icon-btn:hover:not(:disabled) {
      background: var(--bg-2);
      border-color: var(--text-1);
      color: var(--text-0);
    }

    .btn:disabled,
    .icon-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .btn-primary {
      background: transparent;
      color: var(--text-0);
      border-color: var(--text-0);
      font-weight: 700;
      min-width: 132px;
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--bg-2);
      border-color: var(--text-0);
    }

    .live-tune-state {
      min-width: 112px;
      height: 24px;
      border: 1px solid var(--line);
      background: var(--bg-2);
      color: var(--text-2);
      padding: 0 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-mono);
      font-size: 9px;
      letter-spacing: 0.09em;
      text-transform: uppercase;
      white-space: nowrap;
      transition: color var(--ease), border-color var(--ease), opacity var(--ease);
    }

    .live-tune-state.off {
      opacity: 0.62;
    }

    .live-tune-state.idle {
      color: var(--text-1);
      border-color: var(--line-strong);
    }

    .live-tune-state.queued {
      color: var(--accent-warn);
      border-color: var(--accent-warn);
      opacity: 1;
    }

    .live-tune-state.applying {
      color: var(--accent-gpu);
      border-color: var(--accent-gpu);
      opacity: 1;
    }

    .live-tune-state.synced {
      color: var(--accent-running);
      border-color: var(--accent-running);
      opacity: 1;
    }

    .btn-spinner {
      width: 11px;
      height: 11px;
      border: 1px solid transparent;
      border-top-color: currentColor;
      border-right-color: currentColor;
      opacity: 0;
      animation: spin 700ms linear infinite;
      pointer-events: none;
    }

    #startBtn .btn-spinner {
      display: none;
    }

    #startBtn.is-loading .btn-spinner {
      display: inline-block;
    }

    .btn.is-loading .btn-spinner {
      opacity: 1;
    }

    @keyframes spin {
      to { transform: rotate(1turn); }
    }

    .mobile-only {
      display: none;
    }

    .drawer-backdrop {
      position: fixed;
      inset: 42px 0 0 0;
      background: rgba(0, 0, 0, 0.7);
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--ease);
      z-index: 10;
    }

    .workspace {
      flex: 1;
      min-height: 0;
      display: grid;
      grid-template-columns: minmax(250px, 21vw) minmax(0, 1fr) minmax(220px, 18vw);
      gap: var(--space-3);
      padding: var(--space-3);
    }

    .app-footer {
      height: 16px;
      border-top: 1px solid var(--line);
      background: var(--bg-1);
      color: var(--text-2);
      font-family: var(--font-mono);
      font-size: 9px;
      letter-spacing: 0.04em;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 0 10px;
      flex-shrink: 0;
      white-space: nowrap;
    }

    .sidebar {
      min-width: 0;
      min-height: 0;
      border: 1px solid var(--line);
      background: var(--bg-1);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-header {
      height: 36px;
      border-bottom: 1px solid var(--line);
      padding: 0 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      flex-shrink: 0;
    }

    .sidebar-title {
      font-size: 10px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--text-1);
      white-space: nowrap;
    }

    .sidebar-scroll {
      min-height: 0;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 0;
      padding: 0 10px;
    }

    .panel {
      border: none;
      background: transparent;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .panel + .panel {
      border-top: 1px solid var(--line);
    }

    .panel-toggle {
      border: none;
      border-bottom: 1px solid var(--line);
      background: transparent;
      color: var(--text-0);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      width: 100%;
      min-height: 32px;
      padding: 0 12px;
      font-size: 10px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      cursor: pointer;
      font-family: var(--font-sans);
      font-weight: 700;
      transition: background var(--ease), color var(--ease);
    }

    .panel-toggle:hover {
      background: #101010;
      color: var(--text-0);
    }

    .panel-title {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--text-0);
    }

    .chevron {
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--text-2);
      transition: transform var(--ease), color var(--ease);
      flex-shrink: 0;
    }

    .panel.is-collapsed .chevron {
      transform: rotate(-90deg);
      color: var(--text-1);
    }

    .panel-body {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
    }

    .panel.is-collapsed .panel-body {
      display: none;
    }

    .control-row {
      display: grid;
      grid-template-columns: 88px minmax(0, 1fr);
      align-items: center;
      gap: var(--space-2);
      min-height: 30px;
    }

    .control-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.11em;
      color: #7a7a7a;
      white-space: nowrap;
      transition: color var(--ease);
    }

    .control-row:hover .control-label,
    .control-row:focus-within .control-label {
      color: var(--text-1);
    }

    .control-field,
    .control-slider-wrap {
      min-width: 0;
    }

    .control-hint {
      margin-top: -2px;
      margin-left: 88px;
      min-height: 14px;
      color: var(--text-2);
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-family: var(--font-mono);
      line-height: 1.3;
    }

    .control-hint strong {
      color: var(--text-1);
      font-weight: 500;
    }

    .control-slider-wrap {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      align-items: center;
      gap: 8px;
    }

    .control-input,
    .control-select,
    .control-slider,
    .toggle-input {
      width: 100%;
      font-family: var(--font-sans);
      font-size: 12px;
      color: var(--text-0);
      border-radius: var(--radius);
      outline: none;
    }

    .control-input,
    .control-select {
      height: 28px;
      border: 1px solid var(--line-strong);
      background: var(--bg-0);
      padding: 0 8px;
      transition: border-color var(--ease), background-color var(--ease);
    }

    .control-select {
      padding-right: 8px;
    }

    .control-input:hover,
    .control-select:hover {
      border-color: #4a4a4a;
    }

    .control-input:focus,
    .control-select:focus {
      border-color: var(--accent-focus);
      background: #0a0a0a;
    }

    .control-input[type="number"],
    .control-input[type="text"] {
      font-family: var(--font-mono);
      color: var(--text-0);
    }

    .control-slider {
      appearance: none;
      height: 4px;
      border: none;
      background: #202020;
      cursor: pointer;
    }

    .control-slider::-webkit-slider-thumb {
      appearance: none;
      width: 9px;
      height: 14px;
      border: 1px solid var(--text-0);
      border-radius: 0;
      background: #000000;
    }

    .control-slider::-moz-range-thumb {
      width: 9px;
      height: 14px;
      border: 1px solid var(--text-0);
      border-radius: 0;
      background: #000000;
    }

    .control-slider::-moz-range-track {
      height: 4px;
      background: #202020;
    }

    .metric {
      width: 52px;
      text-align: right;
      font-family: var(--font-mono);
      color: var(--text-0);
      font-size: 11px;
      letter-spacing: 0.01em;
    }

    .toggle-wrap {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--text-1);
      font-family: var(--font-mono);
      font-size: 11px;
      user-select: none;
      justify-self: start;
    }

    .toggle-input {
      appearance: none;
      width: 30px;
      height: 16px;
      border: 1px solid var(--line-strong);
      border-radius: 0;
      background: #0a0a0a;
      position: relative;
      cursor: pointer;
    }

    .toggle-input::after {
      content: "";
      position: absolute;
      top: 1px;
      left: 1px;
      width: 10px;
      height: 12px;
      background: var(--text-2);
      transition: transform var(--ease), background var(--ease);
    }

    .toggle-input:checked::after {
      transform: translateX(16px);
      background: var(--text-0);
    }

    .mode-hidden {
      display: none;
    }

    .viewport-stage {
      min-width: 0;
      min-height: 0;
      border: 1px solid var(--line);
      background: var(--bg-1);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .viewport-toolbar {
      height: 36px;
      border-bottom: 1px solid var(--line);
      padding: 0 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      flex-shrink: 0;
    }

    .viewport-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-1);
      white-space: nowrap;
    }

    .viewport-tools {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    .zoom-inline {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--text-2);
      font-family: var(--font-mono);
      font-size: 11px;
      white-space: nowrap;
    }

    .zoom-inline output {
      min-width: 48px;
      text-align: right;
      color: var(--text-0);
    }

    .zoom-slider {
      width: 110px;
    }

    .viewport-frame {
      position: relative;
      flex: 1;
      min-height: 0;
      background: #000000;
      overflow: hidden;
      cursor: crosshair;
    }

    .telemetry-strip {
      height: 24px;
      border-top: 1px solid var(--line);
      background: #0a0a0a;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 10px;
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--text-2);
      overflow-x: auto;
      overflow-y: hidden;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .telemetry-item {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      min-width: 0;
      color: var(--text-2);
      letter-spacing: 0.03em;
    }

    .telemetry-item .label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-2);
    }

    .telemetry-item strong {
      color: var(--text-0);
      font-weight: 500;
      letter-spacing: 0.01em;
    }

    .telemetry-item.ok strong {
      color: var(--accent-running);
    }

    .telemetry-item.warn strong {
      color: var(--accent-warn);
    }

    .viewport-frame.can-pan {
      cursor: grab;
    }

    .viewport-frame.is-dragging {
      cursor: grabbing;
    }

    .preview-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: none;
      image-rendering: auto;
    }

    .hidden-image,
    .hidden-canvas {
      position: absolute;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
      left: -9999px;
      top: -9999px;
    }

    .viewport-placeholder {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      color: var(--text-2);
      padding: var(--space-4);
      font-size: 12px;
      letter-spacing: 0.01em;
    }

    .viewport-hud {
      position: absolute;
      left: 10px;
      top: 10px;
      display: inline-flex;
      gap: 6px;
      z-index: 4;
      pointer-events: none;
    }

    .hud-chip {
      border: 1px solid var(--line-strong);
      background: rgba(0, 0, 0, 0.75);
      color: var(--text-1);
      padding: 4px 8px;
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-family: var(--font-mono);
    }

    .hud-chip strong {
      color: var(--text-0);
      font-weight: 500;
      margin-left: 4px;
      text-transform: none;
      letter-spacing: 0;
    }

    .hud-chip.hud-summary {
      letter-spacing: 0.06em;
      text-transform: none;
      color: var(--text-0);
    }

    .hud-chip.hud-summary strong {
      margin-left: 0;
      letter-spacing: 0.02em;
      font-weight: 500;
    }

    .hud-chip.hud-meta {
      display: none;
    }

    .pixel-readout {
      position: absolute;
      right: 10px;
      bottom: 10px;
      z-index: 4;
      border: 1px solid var(--line-strong);
      background: rgba(0, 0, 0, 0.75);
      color: var(--text-1);
      font-family: var(--font-mono);
      font-size: 10px;
      line-height: 1.35;
      padding: 6px 8px;
      min-width: 150px;
      pointer-events: none;
      letter-spacing: 0.01em;
    }

    .pixel-readout strong {
      display: block;
      color: var(--text-0);
      font-weight: 500;
    }

    .gizmo-overlay {
      position: absolute;
      z-index: 5;
      border: 1px solid var(--line-strong);
      background: rgba(0, 0, 0, 0.85);
      padding: 4px;
      display: none;
      min-width: 116px;
      pointer-events: auto;
    }

    .gizmo-overlay.visible {
      display: block;
    }

    .gizmo-head {
      font-family: var(--font-mono);
      font-size: 9px;
      letter-spacing: 0.08em;
      color: var(--text-1);
      text-transform: uppercase;
      margin-bottom: 4px;
      white-space: nowrap;
    }

    .gizmo-axis-row {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 4px;
    }

    .gizmo-axis-btn {
      height: 20px;
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: transparent;
      color: var(--text-1);
      font-family: var(--font-mono);
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
    }

    .gizmo-axis-btn:hover,
    .gizmo-axis-btn.active {
      border-color: var(--text-0);
      color: var(--text-0);
      background: #121212;
    }

    .file-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }

    .file-item {
      position: relative;
      border: 1px solid var(--line);
      background: #0a0a0a;
      color: var(--text-0);
      padding: 6px;
      display: grid;
      grid-template-columns: 64px minmax(0, 1fr);
      gap: 8px;
      text-align: left;
      cursor: pointer;
      width: 100%;
      min-height: 54px;
      transition: border-color var(--ease), background var(--ease);
      font: inherit;
    }

    .file-item:hover {
      border-color: var(--text-1);
      background: #111111;
    }

    .file-item.active {
      border-color: var(--accent-selection);
      background: #121212;
    }

    .file-item.active::before {
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--accent-selection);
      pointer-events: none;
    }

    .file-thumb {
      border: 1px solid var(--line);
      background: #000;
      width: 64px;
      height: 42px;
      overflow: hidden;
      display: grid;
      place-items: center;
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-2);
      font-family: var(--font-mono);
    }

    .file-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      filter: grayscale(100%);
    }

    .file-meta-block {
      min-width: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 4px;
    }

    .file-name {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--text-0);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-meta {
      font-size: 9px;
      letter-spacing: 0.11em;
      text-transform: uppercase;
      color: var(--text-2);
    }

    .empty-state {
      min-height: 88px;
      border: 1px dashed var(--line-strong);
      background: #0a0a0a;
      color: var(--text-2);
      display: grid;
      place-items: center;
      text-align: center;
      font-family: var(--font-mono);
      font-size: 11px;
      padding: var(--space-3);
    }

    .run-details {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 8px;
    }

    .detail-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid #1f1f1f;
      padding-bottom: 4px;
      min-width: 0;
    }

    .detail-row dt {
      font-size: 9px;
      letter-spacing: 0.11em;
      text-transform: uppercase;
      color: var(--text-2);
      flex-shrink: 0;
    }

    .detail-row dd {
      margin: 0;
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text-0);
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: right;
    }

    .command-preview {
      border: 1px solid var(--line);
      background: #0a0a0a;
      color: var(--text-1);
      font-family: var(--font-mono);
      font-size: 10px;
      line-height: 1.3;
      padding: 8px;
      min-height: 56px;
      max-height: 130px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
      cursor: text;
      position: relative;
    }

    .command-preview::after {
      content: attr(data-copy-hint);
      position: absolute;
      top: 5px;
      right: 8px;
      color: var(--text-2);
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      pointer-events: none;
      opacity: 0;
      transition: opacity var(--ease), color var(--ease);
      background: #0a0a0a;
      padding-left: 6px;
    }

    .command-preview:hover::after,
    .command-preview:focus-visible::after,
    .command-preview.copy-feedback::after {
      opacity: 0.88;
    }

    .command-preview.copy-feedback::after {
      color: var(--accent-running);
    }

    .shortcut-note {
      margin-top: 4px;
      font-size: 9px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--text-2);
      font-family: var(--font-mono);
    }

    .panel-note {
      font-size: 9px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--text-2);
      font-family: var(--font-mono);
    }

    .scene-actions {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }

    .scene-obj-name {
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-2);
      font-family: var(--font-mono);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border: 1px solid var(--line);
      background: #0a0a0a;
      padding: 5px 6px;
      min-height: 22px;
    }

    .scene-btn {
      height: 26px;
      border: 1px solid var(--line);
      background: transparent;
      color: var(--text-1);
      border-radius: var(--radius);
      font-family: var(--font-sans);
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 0 8px;
      text-align: left;
      cursor: pointer;
    }

    .scene-btn:hover {
      border-color: var(--text-1);
      color: var(--text-0);
      background: var(--bg-2);
    }

    .scene-btn.is-active {
      border-color: var(--accent-selection);
      color: var(--text-0);
      background: #101010;
    }

    .scene-object-list {
      border: 1px solid var(--line);
      background: #0a0a0a;
      min-height: 82px;
      max-height: 148px;
      overflow: auto;
      padding: 4px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 4px;
    }

    .scene-object-item {
      height: 24px;
      border: 1px solid var(--line);
      background: transparent;
      color: var(--text-1);
      border-radius: var(--radius);
      font-family: var(--font-mono);
      font-size: 10px;
      text-align: left;
      padding: 0 8px;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .scene-object-item:hover {
      border-color: var(--text-1);
      color: var(--text-0);
    }

    .scene-object-item.active {
      border-color: var(--accent-selection);
      color: var(--text-0);
      background: #111111;
    }

    .scene-inspector {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      border-top: 1px solid var(--line);
      padding-top: 8px;
    }

    .vec3-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
    }

    .vec3-grid .control-input {
      height: 26px;
      font-size: 11px;
      padding: 0 6px;
    }

    .scene-row-actions {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
    }

    .scene-gizmo-mode {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
    }

    .scene-gizmo-mode .scene-btn.active {
      border-color: var(--text-0);
      color: var(--text-0);
      background: #121212;
    }

    .shortcut-inline {
      font-size: 9px;
      letter-spacing: 0.09em;
      text-transform: uppercase;
      color: var(--text-2);
      font-family: var(--font-mono);
      white-space: nowrap;
      transition: color var(--ease);
    }

    .shortcut-inline.is-active {
      color: var(--accent-running);
    }

    .thumb-hover-preview {
      position: fixed;
      z-index: 80;
      width: 200px;
      border: 1px solid var(--line-strong);
      background: var(--bg-0);
      padding: 6px;
      pointer-events: none;
      display: none;
    }

    .thumb-hover-preview.visible {
      display: block;
    }

    .thumb-hover-preview img {
      width: 100%;
      height: 112px;
      object-fit: cover;
      display: block;
      border: 1px solid var(--line);
      filter: grayscale(100%);
      background: #000000;
    }

    .thumb-hover-label {
      margin-top: 5px;
      font-size: 9px;
      color: var(--text-1);
      font-family: var(--font-mono);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .hover-help-tooltip {
      position: fixed;
      z-index: 85;
      max-width: min(260px, calc(100vw - 16px));
      border: 1px solid var(--line);
      background: #0b0b0b;
      color: var(--text-1);
      padding: 5px 7px;
      font-family: var(--font-sans);
      font-size: 9px;
      line-height: 1.45;
      letter-spacing: 0;
      pointer-events: none;
      opacity: 0;
      transform: translateY(2px);
      transition: opacity var(--ease), transform var(--ease);
      display: none;
      word-break: break-word;
    }

    .hover-help-tooltip.visible {
      display: block;
      opacity: 0.94;
      transform: translateY(0);
    }

    .app.left-collapsed .workspace {
      grid-template-columns: 40px minmax(0, 1fr) minmax(220px, 18vw);
    }

    .app.right-collapsed .workspace {
      grid-template-columns: minmax(250px, 21vw) minmax(0, 1fr) 40px;
    }

    .app.left-collapsed.right-collapsed .workspace {
      grid-template-columns: 40px minmax(0, 1fr) 40px;
    }

    .app.left-collapsed .sidebar-left .sidebar-title,
    .app.right-collapsed .sidebar-right .sidebar-title,
    .app.left-collapsed .sidebar-left .sidebar-scroll,
    .app.right-collapsed .sidebar-right .sidebar-scroll {
      display: none;
    }

    .app.left-collapsed .sidebar-left .sidebar-header,
    .app.right-collapsed .sidebar-right .sidebar-header {
      justify-content: center;
      padding: 0;
      border-bottom: none;
      height: 100%;
    }

    .app.left-collapsed .sidebar-left .icon-btn,
    .app.right-collapsed .sidebar-right .icon-btn {
      width: 24px;
      height: 24px;
    }

    .app.is-running .runtime-control {
      opacity: 1;
    }

    .app.is-running .runtime-control:disabled {
      opacity: 0.45;
    }

    .app.is-running .status-item {
      border-color: var(--line-strong);
      color: var(--text-0);
    }

    .app.is-fullscreen .viewport-stage {
      border-color: #444;
    }

    :focus-visible {
      outline: 1px solid var(--accent-focus);
      outline-offset: 1px;
    }

    * {
      scrollbar-width: thin;
      scrollbar-color: #2a2a2a #090909;
    }

    ::-webkit-scrollbar {
      width: 4px;
      height: 4px;
    }

    ::-webkit-scrollbar-track {
      background: #090909;
    }

    ::-webkit-scrollbar-thumb {
      background: #2a2a2a;
      border: none;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #343434;
    }

    @media (max-width: 1100px) {
      .mobile-only {
        display: inline-flex;
      }

      .topbar-center {
        justify-content: flex-start;
        overflow: auto;
      }

      .workspace,
      .app.left-collapsed .workspace,
      .app.right-collapsed .workspace,
      .app.left-collapsed.right-collapsed .workspace {
        grid-template-columns: 1fr;
      }

      .sidebar {
        position: fixed;
        top: 42px;
        bottom: 0;
        width: min(84vw, 320px);
        z-index: 20;
        transition: transform var(--ease);
      }

      .sidebar-left {
        left: 0;
        transform: translateX(-102%);
      }

      .sidebar-right {
        right: 0;
        transform: translateX(102%);
      }

      .app.show-left .sidebar-left {
        transform: translateX(0);
      }

      .app.show-right .sidebar-right {
        transform: translateX(0);
      }

      .app.show-left .drawer-backdrop,
      .app.show-right .drawer-backdrop {
        opacity: 1;
        pointer-events: auto;
      }

      .sidebar-header {
        height: 36px;
      }

      .viewport-toolbar {
        height: auto;
        min-height: 36px;
        padding: 6px 8px;
        flex-wrap: wrap;
      }

      .zoom-slider {
        width: 88px;
      }

      .topbar-right {
        gap: 6px;
      }

      .top-inline-label {
        display: none;
      }

      .top-select {
        min-width: 96px;
      }

      .btn,
      .icon-btn {
        padding: 0 9px;
      }

      .btn-primary {
        min-width: 108px;
      }

      .live-tune-state {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="app" class="app state-idle">
    <div id="errorBanner" class="error-banner" role="status" aria-live="polite"></div>
    <div id="gpuBanner" class="gpu-banner" role="status" aria-live="polite"></div>

    <header class="topbar">
      <div class="topbar-left">
        <button id="mobileLeftBtn" class="icon-btn mobile-only" type="button" title="Open controls" aria-label="Open controls">L</button>
        <div class="brand">
          <span class="brand-text">RAYCISM ENGINE</span>
        </div>
      </div>

      <div class="topbar-center" aria-label="Render status">
        <div class="status-item status-state">
          <span id="stateDot" class="state-dot" aria-hidden="true"></span>
          <strong id="stateText">Idle</strong>
        </div>
        <div class="status-item">Backend <strong id="backendText">-</strong></div>
        <div class="status-item">Time <strong id="durationText">0.0s</strong></div>
        <div class="status-item">Samples <strong id="samplesText">-</strong></div>
      </div>

      <div class="topbar-right">
        <div class="top-demo-wrap">
          <span class="top-inline-label">Demo</span>
          <select id="demoPresetSelect" class="top-select" aria-label="Scene preset">
            <option value="editable" selected>Editable</option>
            <option value="demo_tree">Demo Tree</option>
            <option value="demo_person">Demo Person</option>
          </select>
        </div>
        <span id="liveTuneState" class="live-tune-state off" aria-live="polite">Live Tune Off</span>
        <button id="hoverHelpToggleBtn" class="btn" type="button" aria-label="Toggle hover help hints" aria-pressed="true" data-help="Enable or disable delayed hover help hints.">Hints On</button>
        <button id="refreshBtn" class="btn" type="button" aria-label="Refresh status">Refresh</button>
        <button id="stopBtn" class="btn" type="button" disabled>Stop</button>
        <button id="startBtn" class="btn btn-primary" type="button">
          <span class="btn-spinner" aria-hidden="true"></span>
          <span id="startBtnText">Start Render</span>
        </button>
        <button id="mobileRightBtn" class="icon-btn mobile-only" type="button" title="Open outputs" aria-label="Open outputs">R</button>
      </div>
    </header>

    <div id="drawerBackdrop" class="drawer-backdrop"></div>

    <main class="workspace">
      <aside id="leftSidebar" class="sidebar sidebar-left" aria-label="Control panel">
        <div class="sidebar-header">
          <span class="sidebar-title">Controls</span>
          <button id="toggleLeftSidebar" class="icon-btn" type="button" title="Collapse controls" aria-label="Collapse controls">&lt;</button>
        </div>

        <div class="sidebar-scroll">
          <section class="panel" id="sessionPanel">
            <button class="panel-toggle" type="button" data-panel-toggle aria-expanded="true">
              <span class="panel-title">Session</span>
              <span class="chevron" aria-hidden="true">^</span>
            </button>
            <div class="panel-body">
              <div class="control-row">
                <label class="control-label" for="modeSelect">Mode</label>
                <div class="control-field">
                  <select id="modeSelect" class="control-select runtime-control" data-disable-on-run>
                    <option value="live">Live Preview</option>
                    <option value="render">Final Render</option>
                  </select>
                </div>
              </div>

              <div class="control-row">
                <label class="control-label">Environment</label>
                <div class="control-field">
                  <input id="environmentNameInput" class="control-input" type="text" value="Editable Environment" readonly>
                </div>
              </div>
              <div class="control-row" style="display:none;">
                <label class="control-label" for="demoSelect">Demo</label>
                <div class="control-field">
                  <select id="demoSelect" class="control-select runtime-control" data-disable-on-run aria-hidden="true" tabindex="-1">
                    <option value="scene_editor" title="Live editable primitive scene (sphere, cube, plane, light)." selected>Editable Environment</option>
                  </select>
                </div>
              </div>
              <p id="demoHint" class="control-hint" aria-live="polite" style="display:none;">Live editable primitive scene. <strong>GPU-ready</strong></p>

              <div class="control-row">
                <label class="control-label" for="backendSelect">Backend</label>
                <div class="control-field">
                  <select id="backendSelect" class="control-select runtime-control" data-disable-on-run>
                    <option value="auto">Auto</option>
                    <option value="cpu">CPU</option>
                    <option value="gpu">GPU</option>
                  </select>
                </div>
              </div>

              <div class="control-row">
                <label class="control-label" for="seedInput">Seed</label>
                <div class="control-field"><input id="seedInput" class="control-input runtime-control" data-disable-on-run type="number" min="0" max="2147483647" value="7"></div>
              </div>
            </div>
          </section>

          <section class="panel" id="scenePanel">
            <button class="panel-toggle" type="button" data-panel-toggle aria-expanded="true">
              <span class="panel-title">Scene</span>
              <span class="chevron" aria-hidden="true">^</span>
            </button>
            <div class="panel-body">
              <div class="scene-actions">
                <button id="addSphereBtn" class="scene-btn" type="button">+ Add Sphere</button>
                <button id="addCubeBtn" class="scene-btn" type="button">+ Add Cube</button>
                <button id="addPlaneBtn" class="scene-btn" type="button">+ Add Plane</button>
                <button id="addLightBtn" class="scene-btn" type="button">+ Add Light</button>
                <button id="importObjBtn" class="scene-btn" type="button">Import OBJ + Assets</button>
                <button id="clearObjBtn" class="scene-btn" type="button">Clear OBJ</button>
                <button id="toggleObjSceneBtn" class="scene-btn" type="button" disabled>Add OBJ to Scene</button>
                <input id="objFileInput" type="file" accept=".obj,.mtl,.ppm,.png,.jpg,.jpeg,.bmp,.tga,.gif,.webp" multiple hidden>
              </div>
              <div id="objImportName" class="scene-obj-name">OBJ: None</div>

              <p class="panel-note">Objects</p>
              <div id="sceneObjectList" class="scene-object-list" aria-label="Scene objects"></div>

              <div class="scene-inspector">
                <p class="panel-note">Transform</p>
                <label class="control-label" for="scenePosX">Position (X Y Z)</label>
                <div class="vec3-grid">
                  <input id="scenePosX" class="control-input" type="number" step="0.01">
                  <input id="scenePosY" class="control-input" type="number" step="0.01">
                  <input id="scenePosZ" class="control-input" type="number" step="0.01">
                </div>

                <label class="control-label" for="sceneRotX">Rotation (X Y Z)</label>
                <div class="vec3-grid">
                  <input id="sceneRotX" class="control-input" type="number" step="0.1">
                  <input id="sceneRotY" class="control-input" type="number" step="0.1">
                  <input id="sceneRotZ" class="control-input" type="number" step="0.1">
                </div>

                <label class="control-label" for="sceneScaleX">Scale (X Y Z)</label>
                <div class="vec3-grid">
                  <input id="sceneScaleX" class="control-input" type="number" min="0.05" step="0.01">
                  <input id="sceneScaleY" class="control-input" type="number" min="0.05" step="0.01">
                  <input id="sceneScaleZ" class="control-input" type="number" min="0.05" step="0.01">
                </div>

                <label class="control-label" for="sceneMaterialSelect">Material</label>
                <div class="control-field">
                  <select id="sceneMaterialSelect" class="control-select">
                    <option value="lambertian">Lambertian</option>
                    <option value="metal">Metal</option>
                    <option value="dielectric">Dielectric</option>
                    <option value="coated">Coated</option>
                    <option value="emissive">Emissive</option>
                  </select>
                </div>

                <label class="control-label" for="sceneColorR">Color RGB (0..1)</label>
                <div class="vec3-grid">
                  <input id="sceneColorR" class="control-input" type="number" min="0" max="1" step="0.01">
                  <input id="sceneColorG" class="control-input" type="number" min="0" max="1" step="0.01">
                  <input id="sceneColorB" class="control-input" type="number" min="0" max="1" step="0.01">
                </div>

                <p class="panel-note">Gizmo Mode</p>
                <div class="scene-gizmo-mode">
                  <button id="gizmoMoveBtn" class="scene-btn active" type="button">Move (G)</button>
                  <button id="gizmoRotateBtn" class="scene-btn" type="button">Rotate (R)</button>
                  <button id="gizmoScaleBtn" class="scene-btn" type="button">Scale (S)</button>
                </div>

                <p class="panel-note">Axis Lock</p>
                <div class="scene-gizmo-mode">
                  <button id="sceneAxisXBtn" class="scene-btn active" type="button">X</button>
                  <button id="sceneAxisYBtn" class="scene-btn" type="button">Y</button>
                  <button id="sceneAxisZBtn" class="scene-btn" type="button">Z</button>
                  <button id="sceneAxisUBtn" class="scene-btn" type="button">U</button>
                </div>

                <div class="scene-row-actions">
                  <button id="sceneDuplicateBtn" class="scene-btn" type="button">Duplicate</button>
                  <button id="sceneResetBtn" class="scene-btn" type="button">Reset</button>
                  <button id="sceneDeleteBtn" class="scene-btn" type="button">Delete</button>
                </div>
                <p class="shortcut-note">G Move, R Rotate, S Scale, Delete Remove</p>
              </div>
            </div>
          </section>

          <section class="panel" id="renderPanel">
            <button class="panel-toggle" type="button" data-panel-toggle aria-expanded="true">
              <span class="panel-title">Render Quality</span>
              <span class="chevron" aria-hidden="true">^</span>
            </button>
            <div class="panel-body">
              <div class="control-row mode-live-group">
                <label class="control-label" for="liveProfileSelect">Profile</label>
                <div class="control-field">
                  <select id="liveProfileSelect" class="control-select runtime-control" data-disable-on-run>
                    <option value="speed" selected>Speed</option>
                    <option value="balanced">Balanced</option>
                    <option value="ultra">Ultra</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
              </div>

              <div class="control-row mode-live-group">
                <label class="control-label" for="liveTuneToggle">Live Tune</label>
                <label class="toggle-wrap" for="liveTuneToggle">
                  <input id="liveTuneToggle" class="toggle-input" type="checkbox" checked>
                  <span>On</span>
                </label>
              </div>

              <div class="control-row mode-render-group">
                <label class="control-label" for="samplesSlider" title="Total light samples per pixel. Higher values reduce noise and increase render time.">Samples</label>
                <div class="control-slider-wrap">
                  <input id="samplesSlider" class="control-slider runtime-control" data-disable-on-run type="range" min="1" max="4000" value="400" title="Total light samples per pixel. Higher values reduce noise and increase render time.">
                  <output id="samplesValue" class="metric">400</output>
                </div>
              </div>

              <div class="control-row mode-render-group">
                <label class="control-label" for="depthSlider" title="Maximum bounce depth for each ray path. Higher depth improves indirect lighting at additional cost.">Depth</label>
                <div class="control-slider-wrap">
                  <input id="depthSlider" class="control-slider runtime-control" data-disable-on-run type="range" min="1" max="64" value="18" title="Maximum bounce depth for each ray path. Higher depth improves indirect lighting at additional cost.">
                  <output id="depthValue" class="metric">18</output>
                </div>
              </div>

              <div class="control-row mode-render-group">
                <label class="control-label" for="threadsSlider" title="Worker threads used for rendering. Higher values improve speed up to CPU limits.">Threads</label>
                <div class="control-slider-wrap">
                  <input id="threadsSlider" class="control-slider runtime-control" data-disable-on-run type="range" min="1" max="64" value="8" title="Worker threads used for rendering. Higher values improve speed up to CPU limits.">
                  <output id="threadsValue" class="metric">8</output>
                </div>
              </div>

              <div class="control-row mode-live-group">
                <label class="control-label" for="liveSamplesSlider" title="Samples contributed per live accumulation frame. Higher values reduce noise but update more slowly.">Samples</label>
                <div class="control-slider-wrap">
                  <input id="liveSamplesSlider" class="control-slider runtime-control" data-disable-on-run type="range" min="1" max="512" value="64" title="Samples contributed per live accumulation frame. Higher values reduce noise but update more slowly.">
                  <output id="liveSamplesValue" class="metric">64</output>
                </div>
              </div>

              <div class="control-row mode-live-group">
                <label class="control-label" for="liveDepthSlider" title="Maximum bounce depth in live mode. Higher depth improves indirect light and reflections.">Depth</label>
                <div class="control-slider-wrap">
                  <input id="liveDepthSlider" class="control-slider runtime-control" data-disable-on-run type="range" min="1" max="64" value="14" title="Maximum bounce depth in live mode. Higher depth improves indirect light and reflections.">
                  <output id="liveDepthValue" class="metric">14</output>
                </div>
              </div>

              <div class="control-row mode-live-group">
                <label class="control-label" for="liveIntervalSlider" title="Target delay between live frames in milliseconds. Lower values increase update rate.">Interval</label>
                <div class="control-slider-wrap">
                  <input id="liveIntervalSlider" class="control-slider runtime-control" data-disable-on-run type="range" min="0" max="1000" step="10" value="24" title="Target delay between live frames in milliseconds. Lower values increase update rate.">
                  <output id="liveIntervalValue" class="metric">24</output>
                </div>
              </div>

              <div class="control-row mode-live-group">
                <label class="control-label" for="threadsSliderLive" title="Worker threads used in live mode. Tune for responsiveness versus system load.">Threads</label>
                <div class="control-slider-wrap">
                  <input id="threadsSliderLive" class="control-slider runtime-control" data-disable-on-run type="range" min="1" max="64" value="8" title="Worker threads used in live mode. Tune for responsiveness versus system load.">
                  <output id="threadsValueLive" class="metric">8</output>
                </div>
              </div>
            </div>
          </section>

          <section class="panel" id="livePanel">
            <button class="panel-toggle" type="button" data-panel-toggle aria-expanded="true">
              <span class="panel-title">Output</span>
              <span class="chevron" aria-hidden="true">^</span>
            </button>
            <div class="panel-body">
              <div class="control-row">
                <label class="control-label" for="widthInput">Width</label>
                <div class="control-field"><input id="widthInput" class="control-input runtime-control" data-disable-on-run type="number" min="64" max="16384" value="1280"></div>
              </div>

              <div class="control-row">
                <label class="control-label" for="heightInput">Height</label>
                <div class="control-field"><input id="heightInput" class="control-input runtime-control" data-disable-on-run type="number" min="64" max="16384" value="720"></div>
              </div>

              <div class="control-row">
                <label class="control-label" for="outputFormatSelect">Format</label>
                <div class="control-field">
                  <select id="outputFormatSelect" class="control-select runtime-control" data-disable-on-run>
                    <option value="ppm" selected>PPM</option>
                    <option value="png">PNG</option>
                    <option value="jpg">JPG</option>
                    <option value="jpeg">JPEG</option>
                    <option value="bmp">BMP</option>
                    <option value="hdr">HDR</option>
                    <option value="exr">EXR</option>
                  </select>
                </div>
              </div>

              <div class="control-row mode-render-group">
                <label class="control-label" for="outputInput">Path</label>
                <div class="control-field"><input id="outputInput" class="control-input runtime-control" data-disable-on-run type="text" value="out/final.ppm"></div>
              </div>

              <div class="control-row mode-live-group">
                <label class="control-label" for="liveOutputInput">Path</label>
                <div class="control-field"><input id="liveOutputInput" class="control-input runtime-control" data-disable-on-run type="text" value="out/live_preview.ppm"></div>
              </div>

              <div class="control-row mode-live-group">
                <label class="control-label" for="liveRecentToggle">Live In Recent</label>
                <label class="toggle-wrap" for="liveRecentToggle">
                  <input id="liveRecentToggle" class="toggle-input runtime-control" data-disable-on-run type="checkbox">
                  <span>On</span>
                </label>
              </div>
            </div>
          </section>
        </div>
      </aside>

      <section id="viewportStage" class="viewport-stage" aria-label="Render preview">
        <div class="viewport-toolbar">
          <span class="viewport-label">Live Render Preview</span>
          <div class="viewport-tools">
            <label class="zoom-inline" for="zoomSlider">Zoom <output id="zoomValue">100%</output></label>
            <input id="zoomSlider" class="control-slider zoom-slider" type="range" min="100" max="1600" step="10" value="100">
            <button id="resetViewBtn" class="btn" type="button">Reset</button>
            <button id="fullscreenBtn" class="btn" type="button">Fullscreen</button>
            <span id="navHint" class="shortcut-inline">Space Start/Stop | F Fullscreen | Hold RMB + WASD/QE Move</span>
          </div>
        </div>

        <div id="viewport" class="viewport-frame" tabindex="0">
          <canvas id="previewCanvas" class="preview-canvas"></canvas>
          <img id="previewImage" class="hidden-image" alt="Render output preview">
          <canvas id="sampleCanvas" class="hidden-canvas" aria-hidden="true"></canvas>

          <div id="previewPlaceholder" class="viewport-placeholder">
            <span id="placeholderText">Run a render to preview output.</span>
          </div>

          <div class="viewport-hud">
            <div class="hud-chip hud-summary"><strong id="hudSummaryValue">-</strong></div>
            <div class="hud-chip hud-meta">Resolution <strong id="hudResolutionValue">-</strong></div>
            <div class="hud-chip hud-meta">Samples <strong id="hudSamplesValue">-</strong></div>
            <div class="hud-chip hud-meta">Time <strong id="hudTimeValue">-</strong></div>
            <div class="hud-chip hud-meta">Output <strong id="hudOutputValue">-</strong></div>
          </div>

          <div class="pixel-readout" aria-live="polite">
            <strong id="pixelCoord">X:- Y:-</strong>
            <span id="pixelValue">R:- G:- B:-</span>
          </div>

          <div id="gizmoOverlay" class="gizmo-overlay" aria-hidden="true">
            <div id="gizmoHead" class="gizmo-head">MOVE | AXIS</div>
            <div class="gizmo-axis-row">
              <button id="gizmoAxisX" class="gizmo-axis-btn" type="button">X</button>
              <button id="gizmoAxisY" class="gizmo-axis-btn" type="button">Y</button>
              <button id="gizmoAxisZ" class="gizmo-axis-btn" type="button">Z</button>
              <button id="gizmoAxisU" class="gizmo-axis-btn" type="button">U</button>
            </div>
          </div>
        </div>

        <div class="telemetry-strip" aria-live="polite" aria-label="System telemetry">
          <span id="telemetryGpuItem" class="telemetry-item">
            <span class="label">GPU</span><strong id="telemetryGpu">N/A</strong>
          </span>
          <span id="telemetryVramItem" class="telemetry-item">
            <span class="label">VRAM</span><strong id="telemetryVram">N/A</strong>
          </span>
          <span id="telemetryCpuItem" class="telemetry-item">
            <span class="label">CPU</span><strong id="telemetryCpu">-</strong>
          </span>
          <span id="telemetryMemItem" class="telemetry-item">
            <span class="label">RAM</span><strong id="telemetryMem">-</strong>
          </span>
          <span id="telemetryRssItem" class="telemetry-item">
            <span class="label">Orion</span><strong id="telemetryRss">-</strong>
          </span>
        </div>
      </section>

      <aside id="rightSidebar" class="sidebar sidebar-right" aria-label="Output panel">
        <div class="sidebar-header">
          <span class="sidebar-title">Output</span>
          <button id="toggleRightSidebar" class="icon-btn" type="button" title="Collapse output panel" aria-label="Collapse output panel">&gt;</button>
        </div>

        <div class="sidebar-scroll">
          <section class="panel" id="outputSettingsPanel">
            <button class="panel-toggle" type="button" data-panel-toggle aria-expanded="true">
              <span class="panel-title">Output Settings</span>
              <span class="chevron" aria-hidden="true">^</span>
            </button>
            <div class="panel-body">
              <div class="control-row">
                <label class="control-label" for="fitModeSelect">Fit</label>
                <div class="control-field">
                  <select id="fitModeSelect" class="control-select">
                    <option value="contain" selected>Contain</option>
                    <option value="cover">Cover</option>
                  </select>
                </div>
              </div>

              <div class="control-row">
                <label class="control-label" for="autoRefreshToggle">Auto Sync</label>
                <label class="toggle-wrap" for="autoRefreshToggle">
                  <input id="autoRefreshToggle" class="toggle-input" type="checkbox" checked>
                  <span>On</span>
                </label>
              </div>

              <p class="shortcut-note">Shortcuts: Space Start/Stop, F Fullscreen</p>
            </div>
          </section>

          <section class="panel" id="recentPanel">
            <button class="panel-toggle" type="button" data-panel-toggle aria-expanded="true">
              <span class="panel-title">Recent Renders</span>
              <span class="chevron" aria-hidden="true">^</span>
            </button>
            <div class="panel-body">
              <p class="panel-note">Showing latest 3 outputs</p>
              <div id="fileList" class="file-list">
                <div class="empty-state">No outputs yet</div>
              </div>
            </div>
          </section>

          <section class="panel" id="runPanel">
            <button class="panel-toggle" type="button" data-panel-toggle aria-expanded="true">
              <span class="panel-title">Run Details</span>
              <span class="chevron" aria-hidden="true">^</span>
            </button>
            <div class="panel-body">
              <dl class="run-details">
                <div class="detail-row"><dt>Mode</dt><dd id="detailMode">-</dd></div>
                <div class="detail-row"><dt>Environment</dt><dd id="detailDemo">editable_environment</dd></div>
                <div class="detail-row"><dt>Backend</dt><dd id="detailBackend">-</dd></div>
                <div class="detail-row"><dt>Profile</dt><dd id="detailProfile">speed</dd></div>
                <div class="detail-row"><dt>Phase</dt><dd id="detailPhase">-</dd></div>
                <div class="detail-row"><dt>FPS</dt><dd id="detailFps">-</dd></div>
                <div class="detail-row"><dt>State</dt><dd id="detailState">Idle</dd></div>
                <div class="detail-row"><dt>Frames</dt><dd id="detailFrames">0</dd></div>
                <div class="detail-row"><dt>Exit</dt><dd id="detailExit">-</dd></div>
              </dl>
              <pre id="commandText" class="command-preview" data-copy-hint="Double-click to copy" tabindex="0" aria-label="Active render command. Double-click to copy.">No active command</pre>
            </div>
          </section>
        </div>
      </aside>
    </main>

    <footer class="app-footer" aria-label="Owner credit">&copy; Archit</footer>

    <div id="thumbHoverPreview" class="thumb-hover-preview" aria-hidden="true">
      <img id="thumbHoverImage" alt="Render thumbnail preview">
      <div id="thumbHoverLabel" class="thumb-hover-label"></div>
    </div>
    <div id="hoverHelp" class="hover-help-tooltip" aria-hidden="true"></div>
  </div>

  <script>
    (() => {
      const DISPLAYABLE_EXT = new Set([".png", ".jpg", ".jpeg", ".webp", ".bmp", ".gif"]);
      const OUTPUT_FORMATS = new Set(["ppm", "png", "jpg", "jpeg", "bmp", "hdr", "exr"]);
      const LIVE_ACCUM_FORMATS = new Set(["ppm", "png", "jpg", "jpeg", "bmp"]);
      const STATIC_GPU_DEMOS = new Set();
      const MAX_UI_THREADS = 64;
      const HOVER_HELP_DELAY_MS = 900;
      const HOVER_HELP_SELECTOR = [
        "button",
        "input",
        "select",
        "textarea",
        ".panel-toggle",
        ".scene-object-item",
        ".gizmo-axis-btn",
        ".scene-btn",
        ".status-item",
        ".top-select",
        "[data-help]",
      ].join(", ");
      const LIVE_EDITABLE_CONTROL_IDS = new Set([
        "liveProfileSelect",
        "liveSamplesSlider",
        "liveDepthSlider",
        "liveIntervalSlider",
        "threadsSliderLive",
        "widthInput",
        "heightInput",
        "liveOutputInput",
        "liveRecentToggle",
      ]);

      const ui = {
        app: document.getElementById("app"),
        errorBanner: document.getElementById("errorBanner"),
        gpuBanner: document.getElementById("gpuBanner"),
        drawerBackdrop: document.getElementById("drawerBackdrop"),

        stateDot: document.getElementById("stateDot"),
        stateText: document.getElementById("stateText"),
        backendText: document.getElementById("backendText"),
        durationText: document.getElementById("durationText"),
        samplesText: document.getElementById("samplesText"),

        startBtn: document.getElementById("startBtn"),
        startBtnText: document.getElementById("startBtnText"),
        stopBtn: document.getElementById("stopBtn"),
        refreshBtn: document.getElementById("refreshBtn"),
        liveTuneState: document.getElementById("liveTuneState"),
        hoverHelpToggleBtn: document.getElementById("hoverHelpToggleBtn"),

        mobileLeftBtn: document.getElementById("mobileLeftBtn"),
        mobileRightBtn: document.getElementById("mobileRightBtn"),
        toggleLeftSidebar: document.getElementById("toggleLeftSidebar"),
        toggleRightSidebar: document.getElementById("toggleRightSidebar"),

        modeSelect: document.getElementById("modeSelect"),
        demoSelect: document.getElementById("demoSelect"),
        demoPresetSelect: document.getElementById("demoPresetSelect"),
        environmentNameInput: document.getElementById("environmentNameInput"),
        demoHint: document.getElementById("demoHint"),
        addSphereBtn: document.getElementById("addSphereBtn"),
        addCubeBtn: document.getElementById("addCubeBtn"),
        addPlaneBtn: document.getElementById("addPlaneBtn"),
        addLightBtn: document.getElementById("addLightBtn"),
        importObjBtn: document.getElementById("importObjBtn"),
        clearObjBtn: document.getElementById("clearObjBtn"),
        toggleObjSceneBtn: document.getElementById("toggleObjSceneBtn"),
        objFileInput: document.getElementById("objFileInput"),
        objImportName: document.getElementById("objImportName"),
        sceneObjectList: document.getElementById("sceneObjectList"),
        scenePosX: document.getElementById("scenePosX"),
        scenePosY: document.getElementById("scenePosY"),
        scenePosZ: document.getElementById("scenePosZ"),
        sceneRotX: document.getElementById("sceneRotX"),
        sceneRotY: document.getElementById("sceneRotY"),
        sceneRotZ: document.getElementById("sceneRotZ"),
        sceneScaleX: document.getElementById("sceneScaleX"),
        sceneScaleY: document.getElementById("sceneScaleY"),
        sceneScaleZ: document.getElementById("sceneScaleZ"),
        sceneMaterialSelect: document.getElementById("sceneMaterialSelect"),
        sceneColorR: document.getElementById("sceneColorR"),
        sceneColorG: document.getElementById("sceneColorG"),
        sceneColorB: document.getElementById("sceneColorB"),
        sceneDuplicateBtn: document.getElementById("sceneDuplicateBtn"),
        sceneResetBtn: document.getElementById("sceneResetBtn"),
        sceneDeleteBtn: document.getElementById("sceneDeleteBtn"),
        gizmoMoveBtn: document.getElementById("gizmoMoveBtn"),
        gizmoRotateBtn: document.getElementById("gizmoRotateBtn"),
        gizmoScaleBtn: document.getElementById("gizmoScaleBtn"),
        sceneAxisXBtn: document.getElementById("sceneAxisXBtn"),
        sceneAxisYBtn: document.getElementById("sceneAxisYBtn"),
        sceneAxisZBtn: document.getElementById("sceneAxisZBtn"),
        sceneAxisUBtn: document.getElementById("sceneAxisUBtn"),
        liveProfileSelect: document.getElementById("liveProfileSelect"),
        liveTuneToggle: document.getElementById("liveTuneToggle"),
        backendSelect: document.getElementById("backendSelect"),
        seedInput: document.getElementById("seedInput"),
        widthInput: document.getElementById("widthInput"),
        heightInput: document.getElementById("heightInput"),
        outputFormatSelect: document.getElementById("outputFormatSelect"),

        samplesSlider: document.getElementById("samplesSlider"),
        samplesValue: document.getElementById("samplesValue"),
        depthSlider: document.getElementById("depthSlider"),
        depthValue: document.getElementById("depthValue"),
        threadsSlider: document.getElementById("threadsSlider"),
        threadsValue: document.getElementById("threadsValue"),
        outputInput: document.getElementById("outputInput"),

        liveSamplesSlider: document.getElementById("liveSamplesSlider"),
        liveSamplesValue: document.getElementById("liveSamplesValue"),
        liveDepthSlider: document.getElementById("liveDepthSlider"),
        liveDepthValue: document.getElementById("liveDepthValue"),
        liveIntervalSlider: document.getElementById("liveIntervalSlider"),
        liveIntervalValue: document.getElementById("liveIntervalValue"),
        threadsSliderLive: document.getElementById("threadsSliderLive"),
        threadsValueLive: document.getElementById("threadsValueLive"),
        liveOutputInput: document.getElementById("liveOutputInput"),
        liveRecentToggle: document.getElementById("liveRecentToggle"),

        renderPanel: document.getElementById("renderPanel"),
        livePanel: document.getElementById("livePanel"),

        previewImage: document.getElementById("previewImage"),
        previewCanvas: document.getElementById("previewCanvas"),
        sampleCanvas: document.getElementById("sampleCanvas"),
        viewportStage: document.getElementById("viewportStage"),
        viewport: document.getElementById("viewport"),
        zoomSlider: document.getElementById("zoomSlider"),
        zoomValue: document.getElementById("zoomValue"),
        resetViewBtn: document.getElementById("resetViewBtn"),
        fullscreenBtn: document.getElementById("fullscreenBtn"),
        navHint: document.getElementById("navHint"),
        telemetryGpuItem: document.getElementById("telemetryGpuItem"),
        telemetryVramItem: document.getElementById("telemetryVramItem"),
        telemetryCpuItem: document.getElementById("telemetryCpuItem"),
        telemetryMemItem: document.getElementById("telemetryMemItem"),
        telemetryRssItem: document.getElementById("telemetryRssItem"),
        telemetryGpu: document.getElementById("telemetryGpu"),
        telemetryVram: document.getElementById("telemetryVram"),
        telemetryCpu: document.getElementById("telemetryCpu"),
        telemetryMem: document.getElementById("telemetryMem"),
        telemetryRss: document.getElementById("telemetryRss"),
        pixelCoord: document.getElementById("pixelCoord"),
        pixelValue: document.getElementById("pixelValue"),

        previewPlaceholder: document.getElementById("previewPlaceholder"),
        placeholderText: document.getElementById("placeholderText"),
        hudSummaryValue: document.getElementById("hudSummaryValue"),
        hudResolutionValue: document.getElementById("hudResolutionValue"),
        hudSamplesValue: document.getElementById("hudSamplesValue"),
        hudTimeValue: document.getElementById("hudTimeValue"),
        hudOutputValue: document.getElementById("hudOutputValue"),
        gizmoOverlay: document.getElementById("gizmoOverlay"),
        gizmoHead: document.getElementById("gizmoHead"),
        gizmoAxisX: document.getElementById("gizmoAxisX"),
        gizmoAxisY: document.getElementById("gizmoAxisY"),
        gizmoAxisZ: document.getElementById("gizmoAxisZ"),
        gizmoAxisU: document.getElementById("gizmoAxisU"),

        fileList: document.getElementById("fileList"),
        fitModeSelect: document.getElementById("fitModeSelect"),
        autoRefreshToggle: document.getElementById("autoRefreshToggle"),

        detailMode: document.getElementById("detailMode"),
        detailDemo: document.getElementById("detailDemo"),
        detailBackend: document.getElementById("detailBackend"),
        detailProfile: document.getElementById("detailProfile"),
        detailPhase: document.getElementById("detailPhase"),
        detailFps: document.getElementById("detailFps"),
        detailState: document.getElementById("detailState"),
        detailFrames: document.getElementById("detailFrames"),
        detailExit: document.getElementById("detailExit"),
        commandText: document.getElementById("commandText"),
        thumbHoverPreview: document.getElementById("thumbHoverPreview"),
        thumbHoverImage: document.getElementById("thumbHoverImage"),
        thumbHoverLabel: document.getElementById("thumbHoverLabel"),
        hoverHelp: document.getElementById("hoverHelp"),

        runtimeControls: Array.from(document.querySelectorAll("[data-disable-on-run]")),
        panelToggles: Array.from(document.querySelectorAll("[data-panel-toggle]")),
        modeRenderGroups: Array.from(document.querySelectorAll(".mode-render-group")),
        modeLiveGroups: Array.from(document.querySelectorAll(".mode-live-group")),
      };

      const state = {
        pollHandle: null,
        pollIntervalMs: 120,
        statusPollInFlight: false,
        statusPollPending: false,
        previewKey: "",
        previewOutput: "",
        previewFallbackTried: false,
        previewImageLoading: false,
        queuedPreview: null,
        currentOutputs: [],
        outputsSignature: "",
        thumbRevision: 0,
        lastStatus: null,
        selectedOutput: "",
        pendingPayload: null,
        outputConfigByName: Object.create(null),
        demoGpuCompat: Object.create(null),
        demoDescriptions: Object.create(null),
        running: false,
        gpuProbeStatus: "unknown",
        gpuProbeMessage: "GPU probe not run yet.",
        liveSettingsTimer: null,
        liveSettingsInFlight: false,
        liveSettingsPending: false,
        liveSettingsSyncedFlashTimer: null,
        commandCopyTimer: null,
        hoverHelpEnabled: true,
        hoverHelpTimer: null,
        hoverHelpTarget: null,
        hoverHelpText: "",
        hoverHelpVisible: false,
        hoverHelpX: 0,
        hoverHelpY: 0,

        liveProfile: "speed",
        liveAdvanced: {
          previewScale: 0.92,
          previewSamples: 20,
          previewDepth: 12,
          refineEvery: 3,
        },

        zoom: 1,
        minZoom: 1,
        maxZoom: 16,
        panX: 0,
        panY: 0,
        dragging: false,
        dragLastX: 0,
        dragLastY: 0,

        sampleCtx: null,
        sampleRefreshAtMs: 0,
        hoverOutputName: "",
        camera: {
          pos: { x: 6.8, y: 4.2, z: 9.5 },
          yaw: -35.57,
          pitch: -15.32,
          fov: 34.0,
          lookActive: false,
          lastMouseX: 0,
          lastMouseY: 0,
          lastTickMs: 0,
          loopHandle: null,
          dirty: false,
          syncInFlight: false,
          syncPending: false,
          lastSentAtMs: 0,
          lastSentSignature: "",
          lastUserInputAtMs: 0,
          keys: {
            forward: false,
            back: false,
            left: false,
            right: false,
            down: false,
            up: false,
            boost: false,
          },
        },

        scene: {
          objects: [],
          selectedId: "",
          presetId: "editable",
          objPath: "",
          objName: "",
          objEnabled: false,
          gizmoMode: "move",
          activeAxis: "x",
          nextIndex: {
            sphere: 1,
            cube: 1,
            plane: 1,
            light: 1,
          },
          drag: null,
          clickCandidate: null,
          lastSentSpec: "",
          lastSentObjPath: "",
          syncTimer: null,
          sceneRevision: 0,
        },
      };

      const DEFAULT_SCENE_OBJECTS = [
        {
          id: "sphere_01",
          type: "sphere",
          name: "Sphere_01",
          position: { x: 0, y: 1, z: -1.8 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 1, y: 1, z: 1 },
          material: "coated",
          color: { r: 0.86, g: 0.86, b: 0.86 },
        },
        {
          id: "light_01",
          type: "light",
          name: "Light_01",
          position: { x: 1.9, y: 3.2, z: 1.0 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 0.5, y: 0.5, z: 0.5 },
          material: "emissive",
          color: { r: 1, g: 1, b: 1 },
        },
        {
          id: "plane_01",
          type: "plane",
          name: "Plane_01",
          position: { x: 0, y: 0, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 12, y: 1, z: 12 },
          material: "lambertian",
          color: { r: 0.42, g: 0.42, b: 0.42 },
        },
      ];

      const TREE_DEMO_OBJECTS = [
        {
          id: "light_01",
          type: "light",
          name: "Light_01",
          position: { x: 2.3, y: 3.3, z: 1.2 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 0.6, y: 0.6, z: 0.6 },
          material: "emissive",
          color: { r: 1, g: 1, b: 1 },
        },
        {
          id: "plane_01",
          type: "plane",
          name: "Plane_01",
          position: { x: 0, y: 0, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 12, y: 1, z: 12 },
          material: "lambertian",
          color: { r: 0.38, g: 0.38, b: 0.38 },
        },
        {
          id: "cube_01",
          type: "cube",
          name: "Cube_01",
          position: { x: 0, y: 1.05, z: -1.8 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 0.55, y: 2.1, z: 0.55 },
          material: "lambertian",
          color: { r: 0.64, g: 0.64, b: 0.64 },
        },
        {
          id: "cube_02",
          type: "cube",
          name: "Cube_02",
          position: { x: 0, y: 2.75, z: -1.8 },
          rotation: { x: 0, y: 26, z: 0 },
          scale: { x: 1.55, y: 0.22, z: 0.32 },
          material: "coated",
          color: { r: 0.8, g: 0.8, b: 0.8 },
        },
        {
          id: "sphere_01",
          type: "sphere",
          name: "Sphere_01",
          position: { x: 0, y: 2.6, z: -1.8 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 1.12, y: 1.12, z: 1.12 },
          material: "coated",
          color: { r: 0.78, g: 0.78, b: 0.78 },
        },
        {
          id: "sphere_02",
          type: "sphere",
          name: "Sphere_02",
          position: { x: -0.9, y: 2.15, z: -1.3 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 0.75, y: 0.75, z: 0.75 },
          material: "coated",
          color: { r: 0.72, g: 0.72, b: 0.72 },
        },
        {
          id: "sphere_03",
          type: "sphere",
          name: "Sphere_03",
          position: { x: 0.92, y: 2.2, z: -2.2 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 0.72, y: 0.72, z: 0.72 },
          material: "coated",
          color: { r: 0.72, g: 0.72, b: 0.72 },
        },
      ];

      const PERSON_DEMO_OBJECTS = [
        {
          id: "light_01",
          type: "light",
          name: "Light_01",
          position: { x: 2.0, y: 3.6, z: 1.8 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 0.55, y: 0.55, z: 0.55 },
          material: "emissive",
          color: { r: 1, g: 1, b: 1 },
        },
        {
          id: "plane_01",
          type: "plane",
          name: "Plane_01",
          position: { x: 0, y: 0, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 10, y: 1, z: 10 },
          material: "lambertian",
          color: { r: 0.4, g: 0.4, b: 0.4 },
        },
        {
          id: "cube_01",
          type: "cube",
          name: "Cube_01",
          position: { x: 0, y: 1.0, z: -1.8 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 0.78, y: 1.3, z: 0.42 },
          material: "coated",
          color: { r: 0.82, g: 0.82, b: 0.82 },
        },
        {
          id: "sphere_01",
          type: "sphere",
          name: "Sphere_01",
          position: { x: 0, y: 2.05, z: -1.8 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 0.36, y: 0.36, z: 0.36 },
          material: "coated",
          color: { r: 0.9, g: 0.9, b: 0.9 },
        },
        {
          id: "cube_02",
          type: "cube",
          name: "Cube_02",
          position: { x: -0.62, y: 1.2, z: -1.8 },
          rotation: { x: 0, y: 0, z: 22 },
          scale: { x: 0.22, y: 0.88, z: 0.22 },
          material: "lambertian",
          color: { r: 0.7, g: 0.7, b: 0.7 },
        },
        {
          id: "cube_03",
          type: "cube",
          name: "Cube_03",
          position: { x: 0.62, y: 1.2, z: -1.8 },
          rotation: { x: 0, y: 0, z: -22 },
          scale: { x: 0.22, y: 0.88, z: 0.22 },
          material: "lambertian",
          color: { r: 0.7, g: 0.7, b: 0.7 },
        },
      ];

      const LIVE_PROFILES = {
        speed: {
          liveSamples: 24,
          liveDepth: 10,
          intervalMs: 24,
          previewScale: 0.84,
          previewSamples: 8,
          previewDepth: 8,
          refineEvery: 7,
        },
        balanced: {
          liveSamples: 64,
          liveDepth: 14,
          intervalMs: 50,
          previewScale: 0.92,
          previewSamples: 20,
          previewDepth: 12,
          refineEvery: 3,
        },
        ultra: {
          liveSamples: 128,
          liveDepth: 18,
          intervalMs: 90,
          previewScale: 1.0,
          previewSamples: 36,
          previewDepth: 14,
          refineEvery: 2,
        },
      };

      const PANEL_STATE_KEY = "raycism_engine_panel_state_v1";
      const SIDEBAR_STATE_KEY = "raycism_engine_sidebar_state_v1";
      const USER_PREFS_KEY = "raycism_engine_user_prefs_v1";

      function isMobile() {
        return window.matchMedia("(max-width: 1100px)").matches;
      }

      function safeGetStorage(key) {
        try {
          return window.localStorage.getItem(key);
        } catch (_error) {
          return null;
        }
      }

      function safeSetStorage(key, value) {
        try {
          window.localStorage.setItem(key, value);
        } catch (_error) {
          // Ignore storage write failures (private mode / blocked storage).
        }
      }

      function persistUserPreferences() {
        const payload = {
          mode: ui.modeSelect.value,
          backend: ui.backendSelect.value,
          fitMode: ui.fitModeSelect.value,
          autoRefresh: Boolean(ui.autoRefreshToggle.checked),
          liveInRecent: Boolean(ui.liveRecentToggle.checked),
          liveTune: Boolean(ui.liveTuneToggle.checked),
          hoverHelp: Boolean(state.hoverHelpEnabled),
          outputFormat: ui.outputFormatSelect.value,
          liveProfile: state.liveProfile || ui.liveProfileSelect.value || "speed",
        };
        safeSetStorage(USER_PREFS_KEY, JSON.stringify(payload));
      }

      function restoreUserPreferences() {
        const raw = safeGetStorage(USER_PREFS_KEY);
        if (!raw) {
          return;
        }
        try {
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== "object") {
            return;
          }

          const mode = parsed.mode === "render" ? "render" : (parsed.mode === "live" ? "live" : "");
          if (mode) {
            ui.modeSelect.value = mode;
          }

          if (typeof parsed.backend === "string") {
            const canSetBackend = Array.from(ui.backendSelect.options).some((option) => option.value === parsed.backend);
            if (canSetBackend) {
              ui.backendSelect.value = parsed.backend;
            }
          }

          if (parsed.fitMode === "contain" || parsed.fitMode === "cover") {
            ui.fitModeSelect.value = parsed.fitMode;
          }

          if (typeof parsed.autoRefresh === "boolean") {
            ui.autoRefreshToggle.checked = parsed.autoRefresh;
          }

          if (typeof parsed.liveInRecent === "boolean") {
            ui.liveRecentToggle.checked = parsed.liveInRecent;
          }

          if (typeof parsed.liveTune === "boolean") {
            ui.liveTuneToggle.checked = parsed.liveTune;
          }

          if (typeof parsed.hoverHelp === "boolean") {
            state.hoverHelpEnabled = parsed.hoverHelp;
          }

          if (typeof parsed.outputFormat === "string" && OUTPUT_FORMATS.has(parsed.outputFormat)) {
            applyOutputFormat(parsed.outputFormat);
          }

          if (typeof parsed.liveProfile === "string") {
            if (parsed.liveProfile === "custom") {
              markLiveProfileCustom();
            } else if (LIVE_PROFILES[parsed.liveProfile]) {
              applyLiveProfile(parsed.liveProfile);
            }
          }
          updateHoverHelpToggleButton();
        } catch (_error) {
          // Ignore malformed saved preference payloads.
        }
      }

      function primeHoverHelpSources() {
        const titled = Array.from(document.querySelectorAll("[title]"));
        for (const node of titled) {
          if (!(node instanceof HTMLElement)) {
            continue;
          }
          const text = String(node.getAttribute("title") || "").trim();
          if (!text) {
            continue;
          }
          if (!node.dataset.help) {
            node.dataset.help = text;
          }
          node.removeAttribute("title");
        }

        const seededHints = [
          [ui.startBtn, "Start render. Shortcut: Space or Ctrl+Enter."],
          [ui.stopBtn, "Stop current render. Shortcut: Space or Ctrl+Enter."],
          [ui.refreshBtn, "Refresh status, preview, and telemetry."],
          [ui.demoPresetSelect, "Switch between editable and demo scene presets."],
          [ui.liveTuneToggle, "Allow changing live settings during active rendering."],
          [ui.modeSelect, "Switch between live preview and final render mode."],
          [ui.backendSelect, "Select backend preference: auto, GPU, or CPU."],
          [ui.resetViewBtn, "Reset preview zoom and pan to default."],
          [ui.fullscreenBtn, "Toggle fullscreen preview. Shortcut: F."],
          [ui.zoomSlider, "Adjust preview zoom level."],
        ];
        for (const [element, hint] of seededHints) {
          if (element && !element.dataset.help) {
            element.dataset.help = hint;
          }
        }
      }

      function hoverHelpTextForElement(target) {
        if (!(target instanceof HTMLElement)) {
          return "";
        }

        const explicit = String(target.dataset.help || "").trim();
        if (explicit) {
          return explicit;
        }

        const aria = String(target.getAttribute("aria-label") || "").trim();
        if (aria) {
          return aria;
        }

        if (target.id) {
          const label = document.querySelector('label[for="' + target.id + '"]');
          if (label) {
            const labelText = String(label.textContent || "").replace(/\s+/g, " ").trim();
            if (labelText) {
              if (target instanceof HTMLInputElement) {
                if (target.type === "checkbox") {
                  return "Toggle " + labelText + ".";
                }
                if (target.type === "range") {
                  return labelText + " control.";
                }
                return labelText + " value.";
              }
              if (target instanceof HTMLSelectElement) {
                return labelText + " selection.";
              }
              return labelText + ".";
            }
          }
        }

        if (target.classList.contains("panel-toggle")) {
          const panelTitle = target.querySelector(".panel-title");
          const title = panelTitle ? String(panelTitle.textContent || "").trim() : "section";
          if (title) {
            return "Expand or collapse the " + title + " section.";
          }
        }

        const text = String(target.textContent || "").replace(/\s+/g, " ").trim();
        if (text.length > 0 && text.length <= 120) {
          return text;
        }

        return "";
      }

      function hoverHelpTargetFromNode(node) {
        if (!(node instanceof Element)) {
          return null;
        }
        const target = node.closest(HOVER_HELP_SELECTOR);
        if (!(target instanceof HTMLElement)) {
          return null;
        }
        if (target === ui.hoverHelp || target === ui.thumbHoverPreview) {
          return null;
        }
        if (target.getAttribute("aria-hidden") === "true") {
          return null;
        }
        if (
          target instanceof HTMLButtonElement ||
          target instanceof HTMLInputElement ||
          target instanceof HTMLSelectElement ||
          target instanceof HTMLTextAreaElement
        ) {
          if (target.disabled) {
            return null;
          }
        }
        return target;
      }

      function setHoverHelpVisible(visible) {
        if (!ui.hoverHelp) {
          return;
        }
        ui.hoverHelp.classList.toggle("visible", visible);
        ui.hoverHelp.setAttribute("aria-hidden", visible ? "false" : "true");
      }

      function placeHoverHelp(clientX, clientY) {
        if (!ui.hoverHelp || !state.hoverHelpVisible) {
          return;
        }
        const pad = 8;
        const offset = 14;
        const rect = ui.hoverHelp.getBoundingClientRect();
        const maxLeft = Math.max(pad, window.innerWidth - rect.width - pad);
        const maxTop = Math.max(pad, window.innerHeight - rect.height - pad);
        const left = Math.min(maxLeft, Math.max(pad, clientX + offset));
        let top = clientY + offset;
        if (top > maxTop) {
          top = clientY - rect.height - offset;
        }
        top = Math.min(maxTop, Math.max(pad, top));
        ui.hoverHelp.style.left = String(left) + "px";
        ui.hoverHelp.style.top = String(top) + "px";
      }

      function hideHoverHelp() {
        if (state.hoverHelpTimer !== null) {
          window.clearTimeout(state.hoverHelpTimer);
          state.hoverHelpTimer = null;
        }
        state.hoverHelpTarget = null;
        state.hoverHelpText = "";
        state.hoverHelpVisible = false;
        setHoverHelpVisible(false);
      }

      function showHoverHelpNow() {
        if (!ui.hoverHelp || !state.hoverHelpText) {
          return;
        }
        ui.hoverHelp.textContent = state.hoverHelpText;
        state.hoverHelpVisible = true;
        setHoverHelpVisible(true);
        placeHoverHelp(state.hoverHelpX, state.hoverHelpY);
      }

      function scheduleHoverHelp(target, clientX, clientY) {
        if (!state.hoverHelpEnabled) {
          return;
        }
        const text = hoverHelpTextForElement(target);
        if (!text) {
          hideHoverHelp();
          return;
        }

        if (state.hoverHelpTarget === target && state.hoverHelpText === text) {
          state.hoverHelpX = clientX;
          state.hoverHelpY = clientY;
          if (state.hoverHelpVisible) {
            placeHoverHelp(clientX, clientY);
          }
          return;
        }

        hideHoverHelp();
        state.hoverHelpTarget = target;
        state.hoverHelpText = text;
        state.hoverHelpX = clientX;
        state.hoverHelpY = clientY;
        state.hoverHelpTimer = window.setTimeout(() => {
          state.hoverHelpTimer = null;
          const activeTarget = state.hoverHelpTarget;
          if (!(activeTarget instanceof HTMLElement)) {
            return;
          }
          const stillHovered = activeTarget.matches(":hover");
          const stillFocused = document.activeElement === activeTarget;
          if (!stillHovered && !stillFocused) {
            hideHoverHelp();
            return;
          }
          showHoverHelpNow();
        }, HOVER_HELP_DELAY_MS);
      }

      function updateHoverHelpToggleButton() {
        if (!ui.hoverHelpToggleBtn) {
          return;
        }
        ui.hoverHelpToggleBtn.textContent = state.hoverHelpEnabled ? "Hints On" : "Hints Off";
        ui.hoverHelpToggleBtn.setAttribute("aria-pressed", state.hoverHelpEnabled ? "true" : "false");
      }

      function setHoverHelpEnabled(enabled, persist = true) {
        state.hoverHelpEnabled = Boolean(enabled);
        if (!state.hoverHelpEnabled) {
          hideHoverHelp();
        }
        updateHoverHelpToggleButton();
        if (persist) {
          persistUserPreferences();
        }
      }

      function isEditableTarget(target) {
        if (!(target instanceof HTMLElement)) {
          return false;
        }
        const tag = target.tagName;
        return tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || target.isContentEditable;
      }

      function toInt(value, fallback) {
        const parsed = Number.parseInt(String(value), 10);
        return Number.isFinite(parsed) ? parsed : fallback;
      }

      function toFloat(value, fallback) {
        const parsed = Number.parseFloat(String(value));
        return Number.isFinite(parsed) ? parsed : fallback;
      }

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function vecLength(v) {
        return Math.hypot(v.x, v.y, v.z);
      }

      function normalizeVec(v) {
        const len = vecLength(v);
        if (!Number.isFinite(len) || len <= 1e-8) {
          return { x: 0, y: 0, z: 0 };
        }
        return { x: v.x / len, y: v.y / len, z: v.z / len };
      }

      function crossVec(a, b) {
        return {
          x: a.y * b.z - a.z * b.y,
          y: a.z * b.x - a.x * b.z,
          z: a.x * b.y - a.y * b.x,
        };
      }

      function isLiveModeSelected() {
        return ui.modeSelect.value === "live";
      }

      function isLiveSceneNavigationEnabled() {
        const mode = ui.modeSelect.value;
        const demo = ui.demoSelect.value;
        return state.running && mode === "live" && demo === "scene_editor";
      }

      function cameraForwardVector() {
        const yaw = state.camera.yaw * Math.PI / 180;
        const pitch = state.camera.pitch * Math.PI / 180;
        const cp = Math.cos(pitch);
        return normalizeVec({
          x: Math.sin(yaw) * cp,
          y: Math.sin(pitch),
          z: -Math.cos(yaw) * cp,
        });
      }

      function cameraFlatForwardVector() {
        const forward = cameraForwardVector();
        const flat = normalizeVec({ x: forward.x, y: 0, z: forward.z });
        if (vecLength(flat) <= 1e-8) {
          return { x: 0, y: 0, z: -1 };
        }
        return flat;
      }

      function cameraRightVector() {
        const up = { x: 0, y: 1, z: 0 };
        const right = normalizeVec(crossVec(cameraFlatForwardVector(), up));
        if (vecLength(right) <= 1e-8) {
          return { x: 1, y: 0, z: 0 };
        }
        return right;
      }

      function cameraInputActive() {
        const keys = state.camera.keys;
        return keys.forward || keys.back || keys.left || keys.right || keys.down || keys.up;
      }

      function clearCameraMovementKeys() {
        state.camera.keys.forward = false;
        state.camera.keys.back = false;
        state.camera.keys.left = false;
        state.camera.keys.right = false;
        state.camera.keys.down = false;
        state.camera.keys.up = false;
        state.camera.keys.boost = false;
      }

      function cameraPayload() {
        return {
          camera_pos: [
            Number(state.camera.pos.x.toFixed(4)),
            Number(state.camera.pos.y.toFixed(4)),
            Number(state.camera.pos.z.toFixed(4)),
          ],
          camera_yaw: Number(state.camera.yaw.toFixed(4)),
          camera_pitch: Number(state.camera.pitch.toFixed(4)),
          camera_fov: Number(state.camera.fov.toFixed(4)),
        };
      }

      async function syncCameraToBackend(force = false) {
        if (!isSceneEditorDemo()) {
          return;
        }

        const now = performance.now();
        const payload = cameraPayload();
        const signature = JSON.stringify(payload);
        if (!force && !state.camera.dirty && signature === state.camera.lastSentSignature) {
          return;
        }
        const minSyncIntervalMs = (state.camera.lookActive || cameraInputActive()) ? 8 : 24;
        if (!force && (now - state.camera.lastSentAtMs) < minSyncIntervalMs) {
          state.camera.syncPending = true;
          return;
        }
        if (state.camera.syncInFlight) {
          state.camera.syncPending = true;
          return;
        }

        state.camera.syncInFlight = true;
        state.camera.syncPending = false;
        state.camera.lastSentAtMs = now;
        state.camera.lastSentSignature = signature;
        state.camera.dirty = false;
        try {
          await requestJSON("/api/camera", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
        } catch (_error) {
          state.camera.dirty = true;
        } finally {
          state.camera.syncInFlight = false;
          if (state.camera.syncPending) {
            state.camera.syncPending = false;
            window.setTimeout(() => {
              syncCameraToBackend(false);
            }, 0);
          }
        }
      }

      function markCameraDirty() {
        state.camera.dirty = true;
        updateGizmoOverlay();
      }

      function markCameraUserInput() {
        state.camera.lastUserInputAtMs = performance.now();
      }

      function updateNavigationHint() {
        const active = isLiveSceneNavigationEnabled();
        ui.navHint.textContent = active
          ? "Ctrl+Enter Run/Stop | Space Start/Stop | F Fullscreen | WASD/QE Move | RMB Look | Shift Boost"
          : "Ctrl+Enter Run/Stop | Space Start/Stop | F Fullscreen | Start Live to Navigate";
        ui.navHint.classList.toggle("is-active", active && (state.camera.lookActive || cameraInputActive()));
      }

      function beginCameraLook(clientX, clientY) {
        if (!isLiveSceneNavigationEnabled()) {
          return;
        }
        markCameraUserInput();
        state.camera.lookActive = true;
        state.camera.lastMouseX = clientX;
        state.camera.lastMouseY = clientY;
        ensureStatusPolling();
        ui.viewport.classList.add("is-dragging");
        updateNavigationHint();
      }

      function updateCameraLook(clientX, clientY) {
        if (!state.camera.lookActive) {
          return;
        }
        const dx = clientX - state.camera.lastMouseX;
        const dy = clientY - state.camera.lastMouseY;
        state.camera.lastMouseX = clientX;
        state.camera.lastMouseY = clientY;

        const sensitivity = 0.14;
        state.camera.yaw += dx * sensitivity;
        state.camera.pitch = clamp(state.camera.pitch - dy * sensitivity, -89, 89);
        markCameraUserInput();
        markCameraDirty();
      }

      function endCameraLook() {
        if (!state.camera.lookActive) {
          return;
        }
        state.camera.lookActive = false;
        clearCameraMovementKeys();
        state.camera.lastTickMs = 0;
        ensureStatusPolling();
        ui.viewport.classList.remove("is-dragging");
        updateNavigationHint();
      }

      function cameraLoopStep(timestampMs) {
        if (!state.camera.lastTickMs) {
          state.camera.lastTickMs = timestampMs;
        }
        const dt = clamp((timestampMs - state.camera.lastTickMs) / 1000, 0, 0.05);
        state.camera.lastTickMs = timestampMs;

        let moved = false;
        if (isLiveSceneNavigationEnabled() && cameraInputActive()) {
          const forward = cameraFlatForwardVector();
          const right = cameraRightVector();
          const move = { x: 0, y: 0, z: 0 };
          const keys = state.camera.keys;

          if (keys.forward) {
            move.x += forward.x;
            move.z += forward.z;
          }
          if (keys.back) {
            move.x -= forward.x;
            move.z -= forward.z;
          }
          if (keys.right) {
            move.x += right.x;
            move.z += right.z;
          }
          if (keys.left) {
            move.x -= right.x;
            move.z -= right.z;
          }
          if (keys.up) {
            move.y += 1;
          }
          if (keys.down) {
            move.y -= 1;
          }

          const dir = normalizeVec(move);
          if (vecLength(dir) > 1e-8) {
            const speed = keys.boost ? 8.2 : 4.4;
            state.camera.pos.x += dir.x * speed * dt;
            state.camera.pos.y += dir.y * speed * dt;
            state.camera.pos.z += dir.z * speed * dt;
            moved = true;
          }
        }

        if (moved) {
          markCameraUserInput();
          markCameraDirty();
        }
        if (state.camera.dirty && isSceneEditorDemo()) {
          syncCameraToBackend(false);
        }
        if (moved || state.camera.lookActive) {
          renderViewport();
        }

        state.camera.loopHandle = window.requestAnimationFrame(cameraLoopStep);
      }

      function ensureCameraLoop() {
        if (state.camera.loopHandle !== null) {
          return;
        }
        state.camera.loopHandle = window.requestAnimationFrame(cameraLoopStep);
      }

      function applyCameraStatus(status) {
        if (!status || typeof status !== "object") {
          return;
        }
        const localControlActive =
          state.camera.lookActive ||
          cameraInputActive() ||
          (performance.now() - state.camera.lastUserInputAtMs) < 180;
        const pos = Array.isArray(status.camera_pos) ? status.camera_pos : null;
        if (pos && pos.length === 3) {
          const x = toFloat(pos[0], state.camera.pos.x);
          const y = toFloat(pos[1], state.camera.pos.y);
          const z = toFloat(pos[2], state.camera.pos.z);
          if (!localControlActive) {
            state.camera.pos.x = x;
            state.camera.pos.y = y;
            state.camera.pos.z = z;
          }
        }
        if (Number.isFinite(Number(status.camera_yaw)) && !localControlActive) {
          state.camera.yaw = toFloat(status.camera_yaw, state.camera.yaw);
        }
        if (Number.isFinite(Number(status.camera_pitch)) && !localControlActive) {
          state.camera.pitch = clamp(toFloat(status.camera_pitch, state.camera.pitch), -89, 89);
        }
        if (Number.isFinite(Number(status.camera_fov))) {
          state.camera.fov = clamp(toFloat(status.camera_fov, state.camera.fov), 20, 100);
        }
        updateGizmoOverlay();
      }

      function cloneSceneObject(obj) {
        return JSON.parse(JSON.stringify(obj));
      }

      function defaultSceneObjects() {
        return DEFAULT_SCENE_OBJECTS.map((obj) => cloneSceneObject(obj));
      }

      function treeDemoObjects() {
        return TREE_DEMO_OBJECTS.map((obj) => cloneSceneObject(obj));
      }

      function personDemoObjects() {
        return PERSON_DEMO_OBJECTS.map((obj) => cloneSceneObject(obj));
      }

      function normalizeScenePresetId(presetId) {
        const value = String(presetId || "").toLowerCase();
        if (value === "demo_tree") {
          return "demo_tree";
        }
        if (value === "demo_person") {
          return "demo_person";
        }
        return "editable";
      }

      function scenePresetLabel(presetId) {
        if (presetId === "demo_tree") {
          return "Demo / Tree";
        }
        if (presetId === "demo_person") {
          return "Demo / Person";
        }
        return "Editable Environment";
      }

      function outputNameFromPathText(pathText) {
        const text = String(pathText || "").trim();
        if (!text) {
          return "";
        }
        const slash = Math.max(text.lastIndexOf("/"), text.lastIndexOf("\\"));
        return slash >= 0 ? text.slice(slash + 1) : text;
      }

      function sceneObjPathForRender() {
        if (!state.scene.objEnabled) {
          return "";
        }
        return state.scene.objPath || "";
      }

      function setObjSceneEnabled(enabled, sync = true) {
        const hasObj = Boolean((state.scene.objPath || "").trim());
        state.scene.objEnabled = hasObj && Boolean(enabled);

        if (ui.toggleObjSceneBtn) {
          ui.toggleObjSceneBtn.disabled = !hasObj;
          ui.toggleObjSceneBtn.classList.toggle("is-active", state.scene.objEnabled);
          ui.toggleObjSceneBtn.textContent = state.scene.objEnabled ? "OBJ In Scene" : "Add OBJ to Scene";
        }

        updateObjImportLabel();
        if (sync) {
          queueSceneSync();
        }
      }

      function updateObjImportLabel() {
        if (!ui.objImportName) {
          return;
        }
        const name = state.scene.objName || outputNameFromPathText(state.scene.objPath);
        if (!name) {
          ui.objImportName.textContent = "OBJ: None";
          return;
        }
        ui.objImportName.textContent = state.scene.objEnabled
          ? ("OBJ: " + name + " | In Scene")
          : ("OBJ: " + name + " | Imported");
      }

      function sceneObjectsFromPreset(presetId) {
        const normalized = normalizeScenePresetId(presetId);
        if (normalized === "demo_tree") {
          return treeDemoObjects();
        }
        if (normalized === "demo_person") {
          return personDemoObjects();
        }
        return defaultSceneObjects();
      }

      function isSceneEditorDemo() {
        return ui.demoSelect.value === "scene_editor";
      }

      function sceneObjectById(id) {
        return state.scene.objects.find((obj) => obj.id === id) || null;
      }

      function nextSceneName(type) {
        const index = state.scene.nextIndex[type] || 1;
        state.scene.nextIndex[type] = index + 1;
        if (type === "sphere") return "Sphere_" + String(index).padStart(2, "0");
        if (type === "cube") return "Cube_" + String(index).padStart(2, "0");
        if (type === "plane") return "Plane_" + String(index).padStart(2, "0");
        return "Light_" + String(index).padStart(2, "0");
      }

      function updateSceneCounterFromExisting() {
        const buckets = { sphere: 1, cube: 1, plane: 1, light: 1 };
        for (const obj of state.scene.objects) {
          const base = obj.type;
          if (!Object.prototype.hasOwnProperty.call(buckets, base)) {
            continue;
          }
          const m = obj.name.match(/_(\d+)$/);
          if (m) {
            const next = Number(m[1]) + 1;
            if (Number.isFinite(next) && next > buckets[base]) {
              buckets[base] = next;
            }
          }
        }
        state.scene.nextIndex = buckets;
      }

      function applyScenePreset(presetId, sync = true) {
        ensureSceneEditorDemo();
        const normalizedPreset = normalizeScenePresetId(presetId);
        const objects = sceneObjectsFromPreset(normalizedPreset);
        state.scene.presetId = normalizedPreset;
        state.scene.objects = objects;
        updateSceneCounterFromExisting();
        setSceneSelection(objects[0] ? objects[0].id : "");
        updateNavigationHint();

        if (ui.demoPresetSelect && ui.demoPresetSelect.value !== normalizedPreset) {
          ui.demoPresetSelect.value = normalizedPreset;
        }
        if (ui.environmentNameInput) {
          ui.environmentNameInput.value = scenePresetLabel(normalizedPreset);
        }

        if (sync) {
          queueSceneSync();
        }
      }

      async function fileToBase64(file) {
        const bytes = new Uint8Array(await file.arrayBuffer());
        const chunkSize = 0x8000;
        let binary = "";
        for (let i = 0; i < bytes.length; i += chunkSize) {
          const chunk = bytes.subarray(i, i + chunkSize);
          binary += String.fromCharCode(...chunk);
        }
        return window.btoa(binary);
      }

      async function importObjFiles(files) {
        const fileList = Array.from(files || []).filter((entry) => entry && typeof entry.name === "string");
        if (fileList.length === 0) {
          return;
        }
        ensureSceneEditorDemo();

        const objFile = fileList.find((entry) => String(entry.name || "").toLowerCase().endsWith(".obj")) || null;
        if (!objFile) {
          setError("Select at least one .obj file. Include .mtl/.texture files to keep materials.");
          return;
        }

        const fileName = String(objFile.name || "").trim() || "import.obj";
        ui.importObjBtn.disabled = true;
        ui.clearObjBtn.disabled = true;
        ui.objImportName.textContent = fileList.length > 1 ? "OBJ: Importing bundle..." : "OBJ: Importing...";
        setError("");

        try {
          const payload = {
            filename: fileName,
            content: await objFile.text(),
          };

          if (fileList.length > 1) {
            const assets = [];
            for (const file of fileList) {
              assets.push({
                name: String(file.name || "").trim(),
                data_base64: await fileToBase64(file),
              });
            }
            payload.assets = assets;
          }

          const result = await requestJSON("/api/import_obj", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          const importedStatus = result && result.status && typeof result.status === "object" ? result.status : null;
          const importedPath = result && typeof result.obj_path === "string"
            ? result.obj_path
            : (
              importedStatus && typeof importedStatus.obj_path === "string"
                ? importedStatus.obj_path
                : ""
            );
          if (importedStatus) {
            renderStatus(importedStatus);
          }
          state.scene.objPath = importedPath;
          state.scene.objName = outputNameFromPathText(importedPath) || fileName;
          setObjSceneEnabled(Boolean(importedPath), false);
          queueSceneSync();
        } catch (error) {
          updateObjImportLabel();
          setError(error instanceof Error ? error.message : String(error));
        } finally {
          ui.importObjBtn.disabled = false;
          ui.clearObjBtn.disabled = false;
          ui.objFileInput.value = "";
        }
      }

      function clearImportedObj() {
        state.scene.objPath = "";
        state.scene.objName = "";
        setObjSceneEnabled(false, false);
        queueSceneSync();
      }

      function setSceneSelection(id) {
        const exists = state.scene.objects.some((obj) => obj.id === id);
        state.scene.selectedId = exists ? id : (state.scene.objects[0] ? state.scene.objects[0].id : "");
        renderSceneObjectList();
        syncSceneInspector();
        updateGizmoOverlay();
      }

      function parseSceneVecInput(input, fallback, minimum = -1000, maximum = 1000) {
        const value = toFloat(input.value, fallback);
        return clamp(value, minimum, maximum);
      }

      function parseSceneScaleInput(input, fallback) {
        const value = toFloat(input.value, fallback);
        return clamp(value, 0.05, 100);
      }

      function syncSceneInspector() {
        const obj = sceneObjectById(state.scene.selectedId);
        const disabled = !obj;
        const fields = [
          ui.scenePosX, ui.scenePosY, ui.scenePosZ,
          ui.sceneRotX, ui.sceneRotY, ui.sceneRotZ,
          ui.sceneScaleX, ui.sceneScaleY, ui.sceneScaleZ,
          ui.sceneMaterialSelect, ui.sceneColorR, ui.sceneColorG, ui.sceneColorB,
          ui.sceneDuplicateBtn, ui.sceneResetBtn, ui.sceneDeleteBtn,
          ui.sceneAxisXBtn, ui.sceneAxisYBtn, ui.sceneAxisZBtn, ui.sceneAxisUBtn,
        ];

        for (const field of fields) {
          field.disabled = disabled;
        }
        if (!obj) {
          return;
        }

        ui.scenePosX.value = obj.position.x.toFixed(2);
        ui.scenePosY.value = obj.position.y.toFixed(2);
        ui.scenePosZ.value = obj.position.z.toFixed(2);
        ui.sceneRotX.value = obj.rotation.x.toFixed(1);
        ui.sceneRotY.value = obj.rotation.y.toFixed(1);
        ui.sceneRotZ.value = obj.rotation.z.toFixed(1);
        ui.sceneScaleX.value = obj.scale.x.toFixed(2);
        ui.sceneScaleY.value = obj.scale.y.toFixed(2);
        ui.sceneScaleZ.value = obj.scale.z.toFixed(2);
        ui.sceneMaterialSelect.value = obj.material;
        ui.sceneColorR.value = obj.color.r.toFixed(2);
        ui.sceneColorG.value = obj.color.g.toFixed(2);
        ui.sceneColorB.value = obj.color.b.toFixed(2);
      }

      function renderSceneObjectList() {
        while (ui.sceneObjectList.firstChild) {
          ui.sceneObjectList.removeChild(ui.sceneObjectList.firstChild);
        }

        if (state.scene.objects.length === 0) {
          const empty = document.createElement("div");
          empty.className = "panel-note";
          empty.textContent = "No objects";
          ui.sceneObjectList.appendChild(empty);
          return;
        }

        for (const obj of state.scene.objects) {
          const item = document.createElement("button");
          item.type = "button";
          item.className = "scene-object-item";
          item.textContent = obj.name;
          item.dataset.help = "Select " + obj.name + " for transform and material edits.";
          if (obj.id === state.scene.selectedId) {
            item.classList.add("active");
          }
          item.addEventListener("click", () => {
            setSceneSelection(obj.id);
          });
          ui.sceneObjectList.appendChild(item);
        }
      }

      function encodeSceneSpec() {
        const parts = [];
        for (const obj of state.scene.objects) {
          const cleanName = String(obj.name || obj.id || "Object")
            .replace(/[|;,\s]+/g, "_")
            .slice(0, 48);
          const type = String(obj.type || "sphere").toLowerCase();
          const material = String(obj.material || "lambertian").toLowerCase();
          const pos = [
            Number(obj.position.x).toFixed(4),
            Number(obj.position.y).toFixed(4),
            Number(obj.position.z).toFixed(4),
          ].join(",");
          const rot = [
            Number(obj.rotation.x).toFixed(4),
            Number(obj.rotation.y).toFixed(4),
            Number(obj.rotation.z).toFixed(4),
          ].join(",");
          const scale = [
            clamp(Number(obj.scale.x), 0.05, 100).toFixed(4),
            clamp(Number(obj.scale.y), 0.05, 100).toFixed(4),
            clamp(Number(obj.scale.z), 0.05, 100).toFixed(4),
          ].join(",");
          const color = [
            clamp(Number(obj.color.r), 0, 1).toFixed(4),
            clamp(Number(obj.color.g), 0, 1).toFixed(4),
            clamp(Number(obj.color.b), 0, 1).toFixed(4),
          ].join(",");
          parts.push([type, cleanName, pos, rot, scale, material, color].join("|"));
        }
        return parts.join(";");
      }

      function decodeSceneSpec(spec) {
        const raw = String(spec || "").trim();
        if (!raw) {
          return defaultSceneObjects();
        }
        const result = [];
        const chunks = raw.split(";");
        for (const chunk of chunks) {
          if (!chunk) {
            continue;
          }
          const fields = chunk.split("|");
          if (fields.length < 7) {
            continue;
          }
          const type = String(fields[0] || "").toLowerCase();
          if (!["sphere", "cube", "plane", "light"].includes(type)) {
            continue;
          }
          const parseVec = (text, fallback) => {
            const parts = String(text || "").split(",");
            if (parts.length !== 3) {
              return fallback;
            }
            return {
              x: toFloat(parts[0], fallback.x),
              y: toFloat(parts[1], fallback.y),
              z: toFloat(parts[2], fallback.z),
            };
          };
          const parseColor = (text, fallback) => {
            const v = parseVec(text, fallback);
            return {
              r: clamp(v.x, 0, 1),
              g: clamp(v.y, 0, 1),
              b: clamp(v.z, 0, 1),
            };
          };
          const id = type + "_" + Math.random().toString(36).slice(2, 9);
          result.push({
            id,
            type,
            name: String(fields[1] || id).replace(/[|;]/g, "_"),
            position: parseVec(fields[2], { x: 0, y: 1, z: 0 }),
            rotation: parseVec(fields[3], { x: 0, y: 0, z: 0 }),
            scale: (() => {
              const s = parseVec(fields[4], { x: 1, y: 1, z: 1 });
              return {
                x: clamp(Math.abs(s.x), 0.05, 100),
                y: clamp(Math.abs(s.y), 0.05, 100),
                z: clamp(Math.abs(s.z), 0.05, 100),
              };
            })(),
            material: String(fields[5] || (type === "light" ? "emissive" : "lambertian")).toLowerCase(),
            color: parseColor(fields[6], { x: 0.85, y: 0.85, z: 0.85 }),
          });
        }
        return result.length > 0 ? result : defaultSceneObjects();
      }

      function ensureSceneEditorDemo() {
        if (ui.demoSelect.value !== "scene_editor") {
          const hasSceneEditor = Array.from(ui.demoSelect.options).some((opt) => opt.value === "scene_editor");
          if (hasSceneEditor) {
            ui.demoSelect.value = "scene_editor";
            updateDemoHint();
          }
        }
      }

      async function pushSceneSpec() {
        const spec = encodeSceneSpec();
        const objPath = sceneObjPathForRender();
        if (spec === state.scene.lastSentSpec && objPath === state.scene.lastSentObjPath) {
          return;
        }

        if (!isSceneEditorDemo()) {
          return;
        }
        try {
          const response = await requestJSON("/api/scene", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              scene_spec: spec,
              obj_path: objPath,
            }),
          });
          const status = response && response.status ? response.status : null;
          state.scene.lastSentSpec = spec;
          state.scene.lastSentObjPath = objPath;
          if (status && Number.isFinite(Number(status.scene_revision))) {
            state.scene.sceneRevision = Number(status.scene_revision);
          }
          if (status && typeof status.obj_path === "string") {
            const resolvedObjPath = status.obj_path.trim();
            if (resolvedObjPath !== state.scene.objPath) {
              state.scene.objPath = resolvedObjPath;
              state.scene.objName = outputNameFromPathText(resolvedObjPath);
            }
            setObjSceneEnabled(Boolean(resolvedObjPath), false);
          }
        } catch (error) {
          setError(error instanceof Error ? error.message : String(error));
        }
      }

      function queueSceneSync() {
        if (state.scene.syncTimer) {
          window.clearTimeout(state.scene.syncTimer);
        }
        state.scene.syncTimer = window.setTimeout(() => {
          state.scene.syncTimer = null;
          pushSceneSpec();
        }, 80);
      }

      function markSceneChanged() {
        renderSceneObjectList();
        syncSceneInspector();
        updateGizmoOverlay();
        queueSceneSync();
      }

      function addSceneObject(type) {
        ensureSceneEditorDemo();
        const id = type + "_" + Date.now().toString(36) + "_" + Math.floor(Math.random() * 999).toString(36);
        const name = nextSceneName(type);
        const spawnIndex = state.scene.objects.length + 1;
        const spawnAngle = spawnIndex * 1.0471975512;
        const spawnRadius = 1.2 + (spawnIndex % 3) * 0.35;
        const spawnX = Math.cos(spawnAngle) * spawnRadius;
        const spawnZ = -1.8 + Math.sin(spawnAngle) * spawnRadius * 0.7;
        const obj = {
          id,
          type,
          name,
          position: type === "plane"
            ? { x: 0, y: 0, z: 0 }
            : (type === "light"
              ? { x: spawnX * 0.7, y: 2.9, z: spawnZ * 0.7 }
              : { x: spawnX, y: 1, z: spawnZ }),
          rotation: { x: 0, y: 0, z: 0 },
          scale: type === "plane"
            ? { x: 8, y: 1, z: 8 }
            : (type === "light" ? { x: 0.5, y: 0.5, z: 0.5 } : { x: 1, y: 1, z: 1 }),
          material: type === "light" ? "emissive" : "lambertian",
          color: type === "light" ? { r: 1, g: 1, b: 1 } : { r: 0.85, g: 0.85, b: 0.85 },
        };
        state.scene.objects.push(obj);
        setSceneSelection(id);
        markSceneChanged();
      }

      function duplicateSelectedSceneObject() {
        const src = sceneObjectById(state.scene.selectedId);
        if (!src) {
          return;
        }
        ensureSceneEditorDemo();
        const copy = cloneSceneObject(src);
        copy.id = src.type + "_" + Date.now().toString(36);
        copy.name = nextSceneName(src.type);
        copy.position.x += 0.5;
        copy.position.z += 0.5;
        state.scene.objects.push(copy);
        setSceneSelection(copy.id);
        markSceneChanged();
      }

      function deleteSelectedSceneObject() {
        if (!state.scene.selectedId) {
          return;
        }
        const next = state.scene.objects.filter((obj) => obj.id !== state.scene.selectedId);
        state.scene.objects = next;
        setSceneSelection(next[0] ? next[0].id : "");
        markSceneChanged();
      }

      function resetSelectedSceneTransform() {
        const obj = sceneObjectById(state.scene.selectedId);
        if (!obj) {
          return;
        }
        obj.position = { x: 0, y: obj.type === "plane" ? 0 : 1, z: -1.8 };
        obj.rotation = { x: 0, y: 0, z: 0 };
        obj.scale = obj.type === "plane"
          ? { x: 8, y: 1, z: 8 }
          : (obj.type === "light" ? { x: 0.5, y: 0.5, z: 0.5 } : { x: 1, y: 1, z: 1 });
        syncSceneInspector();
        markSceneChanged();
      }

      function applySceneInspectorToObject() {
        const obj = sceneObjectById(state.scene.selectedId);
        if (!obj) {
          return;
        }
        obj.position.x = parseSceneVecInput(ui.scenePosX, obj.position.x);
        obj.position.y = parseSceneVecInput(ui.scenePosY, obj.position.y);
        obj.position.z = parseSceneVecInput(ui.scenePosZ, obj.position.z);
        obj.rotation.x = parseSceneVecInput(ui.sceneRotX, obj.rotation.x, -3600, 3600);
        obj.rotation.y = parseSceneVecInput(ui.sceneRotY, obj.rotation.y, -3600, 3600);
        obj.rotation.z = parseSceneVecInput(ui.sceneRotZ, obj.rotation.z, -3600, 3600);
        obj.scale.x = parseSceneScaleInput(ui.sceneScaleX, obj.scale.x);
        obj.scale.y = parseSceneScaleInput(ui.sceneScaleY, obj.scale.y);
        obj.scale.z = parseSceneScaleInput(ui.sceneScaleZ, obj.scale.z);
        obj.material = String(ui.sceneMaterialSelect.value || "lambertian");
        obj.color.r = clamp(parseSceneVecInput(ui.sceneColorR, obj.color.r, 0, 1), 0, 1);
        obj.color.g = clamp(parseSceneVecInput(ui.sceneColorG, obj.color.g, 0, 1), 0, 1);
        obj.color.b = clamp(parseSceneVecInput(ui.sceneColorB, obj.color.b, 0, 1), 0, 1);
        markSceneChanged();
      }

      function setGizmoMode(mode) {
        if (!["move", "rotate", "scale"].includes(mode)) {
          return;
        }
        state.scene.gizmoMode = mode;
        ui.gizmoMoveBtn.classList.toggle("active", mode === "move");
        ui.gizmoRotateBtn.classList.toggle("active", mode === "rotate");
        ui.gizmoScaleBtn.classList.toggle("active", mode === "scale");
        updateGizmoOverlay();
      }

      function setGizmoAxis(axis) {
        state.scene.activeAxis = axis;
        ui.gizmoAxisX.classList.toggle("active", axis === "x");
        ui.gizmoAxisY.classList.toggle("active", axis === "y");
        ui.gizmoAxisZ.classList.toggle("active", axis === "z");
        ui.gizmoAxisU.classList.toggle("active", axis === "u");
        ui.sceneAxisXBtn.classList.toggle("active", axis === "x");
        ui.sceneAxisYBtn.classList.toggle("active", axis === "y");
        ui.sceneAxisZBtn.classList.toggle("active", axis === "z");
        ui.sceneAxisUBtn.classList.toggle("active", axis === "u");
      }

      function sceneCameraProject(worldPos) {
        const rect = ui.viewport.getBoundingClientRect();
        const width = rect.width || 1;
        const height = rect.height || 1;
        const aspect = width / height;
        const lookFrom = {
          x: state.camera.pos.x,
          y: state.camera.pos.y,
          z: state.camera.pos.z,
        };
        const forward = cameraForwardVector();
        const lookAt = {
          x: lookFrom.x + forward.x,
          y: lookFrom.y + forward.y,
          z: lookFrom.z + forward.z,
        };
        const up = { x: 0.0, y: 1.0, z: 0.0 };
        const fovDeg = clamp(state.camera.fov, 20, 100);

        const sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z });
        const dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;
        const cross = (a, b) => ({
          x: a.y * b.z - a.z * b.y,
          y: a.z * b.x - a.x * b.z,
          z: a.x * b.y - a.y * b.x,
        });
        const norm = (a) => {
          const len = Math.hypot(a.x, a.y, a.z) || 1;
          return { x: a.x / len, y: a.y / len, z: a.z / len };
        };

        const w = norm(sub(lookFrom, lookAt));
        const u = norm(cross(up, w));
        const v = cross(w, u);
        const p = sub(worldPos, lookFrom);
        const camX = dot(p, u);
        const camY = dot(p, v);
        const camZ = -dot(p, w);
        if (camZ <= 0.01) {
          return null;
        }
        const tanHalf = Math.tan((fovDeg * Math.PI / 180) * 0.5);
        const ndcX = camX / (camZ * tanHalf * aspect);
        const ndcY = camY / (camZ * tanHalf);
        if (!Number.isFinite(ndcX) || !Number.isFinite(ndcY)) {
          return null;
        }
        const px = (ndcX * 0.5 + 0.5) * width;
        const py = (1 - (ndcY * 0.5 + 0.5)) * height;
        if (px < -80 || py < -80 || px > width + 80 || py > height + 80) {
          return null;
        }
        return { x: px, y: py };
      }

      function pickSceneObjectAt(clientX, clientY) {
        if (!isSceneEditorDemo()) {
          return null;
        }
        const rect = ui.viewport.getBoundingClientRect();
        const localX = clientX - rect.left;
        const localY = clientY - rect.top;
        let best = null;
        let bestDist = 20;
        for (const obj of state.scene.objects) {
          const p = sceneCameraProject(obj.position);
          if (!p) {
            continue;
          }
          const dist = Math.hypot(p.x - localX, p.y - localY);
          if (dist < bestDist) {
            bestDist = dist;
            best = obj.id;
          }
        }
        return best;
      }

      function updateGizmoOverlay() {
        const obj = sceneObjectById(state.scene.selectedId);
        if (!obj || !isSceneEditorDemo()) {
          ui.gizmoOverlay.classList.remove("visible");
          return;
        }
        const rect = ui.viewport.getBoundingClientRect();
        const overlayRect = ui.gizmoOverlay.getBoundingClientRect();
        const pad = 10;
        const overlayWidth = Math.max(116, overlayRect.width || 0);
        const x = Math.max(pad, rect.width - overlayWidth - pad);
        const y = pad;
        ui.gizmoOverlay.style.left = x + "px";
        ui.gizmoOverlay.style.top = y + "px";
        ui.gizmoHead.textContent = state.scene.gizmoMode.toUpperCase() + " | AXIS";
        setGizmoAxis(state.scene.activeAxis);
        ui.gizmoOverlay.classList.add("visible");
      }

      function beginSceneDrag(clientX, clientY) {
        const obj = sceneObjectById(state.scene.selectedId);
        if (!obj) {
          return;
        }
        state.scene.drag = {
          startX: clientX,
          startY: clientY,
          objectId: obj.id,
          mode: state.scene.gizmoMode,
          snapshot: cloneSceneObject(obj),
        };
      }

      function updateSceneDrag(clientX, clientY) {
        const drag = state.scene.drag;
        if (!drag) {
          return;
        }
        const obj = sceneObjectById(drag.objectId);
        if (!obj) {
          return;
        }
        const dx = clientX - drag.startX;
        const dy = clientY - drag.startY;
        const delta = (dx - dy) * 0.01;
        const axis = state.scene.activeAxis || "x";

        const applyAxis = (target, base, step, clampMin = null) => {
          if (axis === "u") {
            target.x = base.x + delta * step;
            target.y = base.y + delta * step;
            target.z = base.z + delta * step;
          } else {
            target[axis] = base[axis] + delta * step;
          }
          if (clampMin !== null) {
            target.x = Math.max(clampMin, target.x);
            target.y = Math.max(clampMin, target.y);
            target.z = Math.max(clampMin, target.z);
          }
        };

        if (drag.mode === "move") {
          applyAxis(obj.position, drag.snapshot.position, 4.0);
        } else if (drag.mode === "rotate") {
          applyAxis(obj.rotation, drag.snapshot.rotation, 90.0);
        } else {
          applyAxis(obj.scale, drag.snapshot.scale, 2.0, 0.05);
        }

        syncSceneInspector();
        updateGizmoOverlay();
        queueSceneSync();
      }

      function endSceneDrag() {
        if (!state.scene.drag) {
          return;
        }
        state.scene.drag = null;
        markSceneChanged();
      }

      function initSceneEditor() {
        setGizmoMode("move");
        setGizmoAxis("x");
        const initialPreset = ui.demoPresetSelect ? ui.demoPresetSelect.value : "editable";
        applyScenePreset(initialPreset, false);
        setObjSceneEnabled(Boolean(state.scene.objPath), false);
      }

      function extOf(name) {
        if (!name) {
          return "";
        }
        const idx = name.lastIndexOf(".");
        return idx >= 0 ? name.slice(idx).toLowerCase() : "";
      }

      function outputNameFromPath(pathText) {
        const raw = String(pathText || "").trim();
        if (!raw) {
          return "";
        }
        const slash = Math.max(raw.lastIndexOf("/"), raw.lastIndexOf("\\"));
        return slash >= 0 ? raw.slice(slash + 1) : raw;
      }

      function normalizeFormat(value) {
        const text = String(value || "").toLowerCase().replace(/^\./, "");
        if (OUTPUT_FORMATS.has(text)) {
          return text;
        }
        return "ppm";
      }

      function replaceExtension(pathText, format) {
        const fmt = normalizeFormat(format);
        const source = String(pathText || "").trim();
        if (!source) {
          return "out/final." + fmt;
        }

        const slash = Math.max(source.lastIndexOf("/"), source.lastIndexOf("\\"));
        const dot = source.lastIndexOf(".");
        if (dot > slash) {
          return source.slice(0, dot) + "." + fmt;
        }
        return source + "." + fmt;
      }

      function formatDuration(seconds) {
        const value = Number(seconds);
        if (!Number.isFinite(value) || value < 0) {
          return "0.0s";
        }
        return value.toFixed(1) + "s";
      }

      function formatPercent(value) {
        const number = Number(value);
        if (!Number.isFinite(number) || number < 0) {
          return "-";
        }
        return Math.round(number) + "%";
      }

      function formatMegabytes(value) {
        const number = Number(value);
        if (!Number.isFinite(number) || number < 0) {
          return "-";
        }
        return Math.round(number) + " MB";
      }

      function setTelemetryTone(item, tone) {
        if (!(item instanceof HTMLElement)) {
          return;
        }
        item.classList.remove("ok", "warn");
        if (tone) {
          item.classList.add(tone);
        }
      }

      function renderTelemetry(status) {
        const telemetry = status && typeof status === "object" && status.telemetry && typeof status.telemetry === "object"
          ? status.telemetry
          : null;
        if (!telemetry) {
          ui.telemetryGpu.textContent = "N/A";
          ui.telemetryVram.textContent = "N/A";
          ui.telemetryCpu.textContent = "-";
          ui.telemetryMem.textContent = "-";
          ui.telemetryRss.textContent = "-";
          setTelemetryTone(ui.telemetryGpuItem, "warn");
          setTelemetryTone(ui.telemetryVramItem, "warn");
          setTelemetryTone(ui.telemetryCpuItem, "");
          setTelemetryTone(ui.telemetryMemItem, "");
          setTelemetryTone(ui.telemetryRssItem, "");
          return;
        }

        const gpuAvailable = Boolean(telemetry.gpu_available);
        const gpuUtil = Number(telemetry.gpu_util_percent);
        const gpuMemUsed = Number(telemetry.gpu_mem_used_mb);
        const gpuMemTotal = Number(telemetry.gpu_mem_total_mb);
        const gpuTemp = Number(telemetry.gpu_temp_c);
        const cpuPercent = Number(telemetry.cpu_percent);
        const memPercent = Number(telemetry.mem_percent);
        const rssMb = Number(telemetry.rss_mb);

        if (gpuAvailable) {
          const gpuUtilText = formatPercent(gpuUtil);
          const gpuTempText = Number.isFinite(gpuTemp) && gpuTemp >= 0 ? (" | " + Math.round(gpuTemp) + "C") : "";
          ui.telemetryGpu.textContent = gpuUtilText + gpuTempText;
          setTelemetryTone(ui.telemetryGpuItem, gpuUtil >= 92 ? "warn" : "ok");
        } else {
          ui.telemetryGpu.textContent = "N/A";
          setTelemetryTone(ui.telemetryGpuItem, "warn");
        }

        if (gpuAvailable && Number.isFinite(gpuMemUsed) && Number.isFinite(gpuMemTotal) && gpuMemTotal > 0) {
          ui.telemetryVram.textContent = Math.round(gpuMemUsed) + " / " + Math.round(gpuMemTotal) + " MB";
          const vramRatio = gpuMemUsed / gpuMemTotal;
          setTelemetryTone(ui.telemetryVramItem, vramRatio >= 0.9 ? "warn" : "ok");
        } else {
          ui.telemetryVram.textContent = "N/A";
          setTelemetryTone(ui.telemetryVramItem, "warn");
        }

        ui.telemetryCpu.textContent = formatPercent(cpuPercent);
        setTelemetryTone(ui.telemetryCpuItem, Number.isFinite(cpuPercent) && cpuPercent >= 95 ? "warn" : "");

        ui.telemetryMem.textContent = formatPercent(memPercent);
        setTelemetryTone(ui.telemetryMemItem, Number.isFinite(memPercent) && memPercent >= 92 ? "warn" : "");

        ui.telemetryRss.textContent = formatMegabytes(rssMb);
        setTelemetryTone(ui.telemetryRssItem, "");
      }

      function formatEnvironmentName(demo) {
        if (demo !== "scene_editor") {
          return String(demo || "editable_environment");
        }
        if (state.scene.presetId === "demo_tree") {
          return "demo_tree";
        }
        if (state.scene.presetId === "demo_person") {
          return "demo_person";
        }
        return "editable_environment";
      }

      function setError(message) {
        if (!message) {
          ui.errorBanner.classList.remove("visible");
          ui.errorBanner.textContent = "";
          return;
        }
        ui.errorBanner.classList.add("visible");
        ui.errorBanner.textContent = message;
      }

      function setGpuWarning(message) {
        if (!message) {
          ui.gpuBanner.classList.remove("visible");
          ui.gpuBanner.textContent = "";
          return;
        }
        ui.gpuBanner.classList.add("visible");
        ui.gpuBanner.textContent = message;
      }

      function updateGpuWarning() {
        if (!hasGpuCapableDemos()) {
          setGpuWarning("");
          return;
        }

        if (state.gpuProbeStatus === "ok") {
          setGpuWarning("");
          return;
        }

        if (state.gpuProbeStatus === "unsupported") {
          setGpuWarning(
            "GPU preflight endpoint is unavailable on this server build. " +
            "GPU will be validated when render starts."
          );
          return;
        }

        if (state.gpuProbeStatus === "failed" || state.gpuProbeStatus === "unavailable") {
          setGpuWarning(
            "GPU preflight failed: " + state.gpuProbeMessage +
            " | To enable real-time GPU rendering, run Raycism Engine on a CUDA-capable machine/driver stack."
          );
          return;
        }

        setGpuWarning("Checking GPU runtime availability...");
      }

      function closeDrawers() {
        ui.app.classList.remove("show-left", "show-right");
      }

      function updateSidebarToggleGlyphs() {
        const leftCollapsed = ui.app.classList.contains("left-collapsed");
        const rightCollapsed = ui.app.classList.contains("right-collapsed");
        ui.toggleLeftSidebar.textContent = leftCollapsed ? ">" : "<";
        ui.toggleRightSidebar.textContent = rightCollapsed ? "<" : ">";
      }

      function persistSidebarState() {
        const payload = {
          leftCollapsed: ui.app.classList.contains("left-collapsed"),
          rightCollapsed: ui.app.classList.contains("right-collapsed"),
        };
        safeSetStorage(SIDEBAR_STATE_KEY, JSON.stringify(payload));
      }

      function restoreSidebarState() {
        const raw = safeGetStorage(SIDEBAR_STATE_KEY);
        if (!raw) {
          updateSidebarToggleGlyphs();
          return;
        }

        try {
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === "object") {
            ui.app.classList.toggle("left-collapsed", Boolean(parsed.leftCollapsed));
            ui.app.classList.toggle("right-collapsed", Boolean(parsed.rightCollapsed));
          }
        } catch (_error) {
          // Ignore malformed saved sidebar state.
        }
        updateSidebarToggleGlyphs();
      }

      function toggleSidebar(side) {
        if (isMobile()) {
          const own = side === "left" ? "show-left" : "show-right";
          const other = side === "left" ? "show-right" : "show-left";
          ui.app.classList.remove(other);
          ui.app.classList.toggle(own);
          return;
        }

        const klass = side === "left" ? "left-collapsed" : "right-collapsed";
        ui.app.classList.toggle(klass);
        updateSidebarToggleGlyphs();
        persistSidebarState();
      }

      function setRunningState(running, mode = "render") {
        state.running = running;
        ui.app.classList.toggle("is-running", running);
        ui.startBtn.classList.toggle("is-loading", running);
        ui.startBtnText.textContent = running
          ? (mode === "live" ? "Live Running" : "Rendering")
          : "Start Render";

        ui.startBtn.disabled = running;
        ui.stopBtn.disabled = !running;

        for (const control of ui.runtimeControls) {
          const liveEditable =
            running &&
            mode === "live" &&
            ui.liveTuneToggle.checked &&
            LIVE_EDITABLE_CONTROL_IDS.has(control.id);
          control.disabled = running && !liveEditable;
        }

        if (ui.liveTuneToggle) {
          ui.liveTuneToggle.disabled = running && mode !== "live";
        }

        if (!running) {
          endCameraLook();
          clearCameraMovementKeys();
        }
        updateLiveTuneIndicator();
        ensureStatusPolling();
      }

      function setLiveTuneIndicator(label, tone) {
        if (!ui.liveTuneState) {
          return;
        }
        ui.liveTuneState.textContent = label;
        ui.liveTuneState.classList.remove("off", "idle", "queued", "applying", "synced");
        ui.liveTuneState.classList.add(tone);
      }

      function updateLiveTuneIndicator() {
        const mode = state.lastStatus && typeof state.lastStatus.mode === "string"
          ? state.lastStatus.mode
          : ui.modeSelect.value;

        if (mode !== "live") {
          setLiveTuneIndicator("Live Tune N/A", "off");
          return;
        }

        if (!ui.liveTuneToggle.checked) {
          setLiveTuneIndicator("Live Tune Off", "off");
          return;
        }

        if (!state.running) {
          setLiveTuneIndicator("Live Tune Ready", "idle");
          return;
        }

        if (state.liveSettingsInFlight) {
          setLiveTuneIndicator("Applying...", "applying");
          return;
        }

        if (state.liveSettingsPending || state.liveSettingsTimer !== null) {
          setLiveTuneIndicator("Update Queued", "queued");
          return;
        }

        setLiveTuneIndicator("In Sync", "synced");
      }

      function flashLiveTuneSynced() {
        if (state.liveSettingsSyncedFlashTimer !== null) {
          window.clearTimeout(state.liveSettingsSyncedFlashTimer);
        }
        setLiveTuneIndicator("Settings Synced", "synced");
        state.liveSettingsSyncedFlashTimer = window.setTimeout(() => {
          state.liveSettingsSyncedFlashTimer = null;
          updateLiveTuneIndicator();
        }, 950);
      }

      function shouldAllowLiveSettingsPush() {
        if (!state.running) {
          return false;
        }
        const runningMode = state.lastStatus && typeof state.lastStatus.mode === "string"
          ? state.lastStatus.mode
          : ui.modeSelect.value;
        return runningMode === "live" && Boolean(ui.liveTuneToggle.checked);
      }

      function buildLiveSettingsPayload() {
        const width = clampIntValue(ui.widthInput.value, 1280, 64, 16384);
        const height = clampIntValue(ui.heightInput.value, 720, 64, 16384);
        const threads = clampIntValue(ui.threadsSliderLive.value, 8, 1, MAX_UI_THREADS);
        const liveSamples = clampIntValue(ui.liveSamplesSlider.value, 64, 1, 512);
        const liveDepth = clampIntValue(ui.liveDepthSlider.value, 14, 1, 64);
        const liveInterval = clampIntValue(ui.liveIntervalSlider.value, 24, 0, 10000);

        let liveOutputFormat = normalizeFormat(ui.outputFormatSelect.value);
        if (!LIVE_ACCUM_FORMATS.has(liveOutputFormat)) {
          const currentLiveExt = extOf(ui.liveOutputInput.value).replace(/^\./, "");
          liveOutputFormat = LIVE_ACCUM_FORMATS.has(currentLiveExt) ? currentLiveExt : "ppm";
        }

        ui.widthInput.value = String(width);
        ui.heightInput.value = String(height);
        ui.threadsSliderLive.value = String(threads);
        ui.threadsValueLive.textContent = ui.threadsSliderLive.value;
        ui.liveSamplesSlider.value = String(liveSamples);
        ui.liveSamplesValue.textContent = ui.liveSamplesSlider.value;
        ui.liveDepthSlider.value = String(liveDepth);
        ui.liveDepthValue.textContent = ui.liveDepthSlider.value;
        ui.liveIntervalSlider.value = String(liveInterval);
        ui.liveIntervalValue.textContent = ui.liveIntervalSlider.value;

        const payload = {
          width,
          height,
          threads,
          live_samples: liveSamples,
          live_depth: liveDepth,
          live_interval_ms: liveInterval,
          live_profile: state.liveProfile || ui.liveProfileSelect.value || "speed",
          live_preview_scale: state.liveAdvanced.previewScale,
          live_preview_samples: state.liveAdvanced.previewSamples,
          live_preview_depth: state.liveAdvanced.previewDepth,
          live_refine_every: state.liveAdvanced.refineEvery,
          live_add_to_recent: Boolean(ui.liveRecentToggle.checked),
          live_output: normalizedOutputPath(ui.liveOutputInput.value, "out/live_preview.ppm", liveOutputFormat),
        };
        ui.liveOutputInput.value = payload.live_output;
        return payload;
      }

      function applyLiveSettingsFromServer(applied) {
        if (!applied || typeof applied !== "object") {
          return;
        }
        if (Number.isFinite(Number(applied.width))) {
          ui.widthInput.value = String(applied.width);
        }
        if (Number.isFinite(Number(applied.height))) {
          ui.heightInput.value = String(applied.height);
        }
        if (Number.isFinite(Number(applied.threads))) {
          ui.threadsSliderLive.value = String(clampIntValue(applied.threads, 8, 1, MAX_UI_THREADS));
        }
        if (Number.isFinite(Number(applied.live_samples))) {
          ui.liveSamplesSlider.value = String(applied.live_samples);
        }
        if (Number.isFinite(Number(applied.live_depth))) {
          ui.liveDepthSlider.value = String(applied.live_depth);
        }
        if (Number.isFinite(Number(applied.live_interval_ms))) {
          ui.liveIntervalSlider.value = String(applied.live_interval_ms);
        }
        if (typeof applied.live_profile === "string") {
          const canSet = Array.from(ui.liveProfileSelect.options).some((option) => option.value === applied.live_profile);
          ui.liveProfileSelect.value = canSet ? applied.live_profile : "custom";
          state.liveProfile = ui.liveProfileSelect.value;
        }
        if (Number.isFinite(Number(applied.live_preview_scale))) {
          state.liveAdvanced.previewScale = clamp(toFloat(applied.live_preview_scale, state.liveAdvanced.previewScale), 0.8, 1.0);
        }
        if (Number.isFinite(Number(applied.live_preview_samples))) {
          state.liveAdvanced.previewSamples = clampIntValue(applied.live_preview_samples, state.liveAdvanced.previewSamples, 1, 64);
        }
        if (Number.isFinite(Number(applied.live_preview_depth))) {
          state.liveAdvanced.previewDepth = clampIntValue(applied.live_preview_depth, state.liveAdvanced.previewDepth, 1, 64);
        }
        if (Number.isFinite(Number(applied.live_refine_every))) {
          state.liveAdvanced.refineEvery = clampIntValue(applied.live_refine_every, state.liveAdvanced.refineEvery, 1, 120);
        }
        if (typeof applied.live_add_to_recent === "boolean") {
          ui.liveRecentToggle.checked = applied.live_add_to_recent;
        }
        if (typeof applied.live_output === "string" && applied.live_output.trim()) {
          ui.liveOutputInput.value = applied.live_output;
        }
        syncSliderLabels();
        syncOutputFormatFromPath();
      }

      function flashCommandCopyHint(text, success) {
        if (!ui.commandText) {
          return;
        }
        ui.commandText.dataset.copyHint = text;
        ui.commandText.classList.add("copy-feedback");
        if (state.commandCopyTimer !== null) {
          window.clearTimeout(state.commandCopyTimer);
        }
        state.commandCopyTimer = window.setTimeout(() => {
          state.commandCopyTimer = null;
          ui.commandText.classList.remove("copy-feedback");
          ui.commandText.dataset.copyHint = "Double-click to copy";
        }, success ? 980 : 1300);
      }

      async function copyCommandPreview() {
        const text = String(ui.commandText.textContent || "").trim();
        if (!text || text === "No active command") {
          flashCommandCopyHint("No active command", false);
          return;
        }

        try {
          if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
            await navigator.clipboard.writeText(text);
            flashCommandCopyHint("Copied", true);
            return;
          }
        } catch (_error) {
          // Fallback below.
        }

        const helper = document.createElement("textarea");
        helper.value = text;
        helper.setAttribute("readonly", "readonly");
        helper.style.position = "absolute";
        helper.style.left = "-9999px";
        document.body.appendChild(helper);
        helper.select();
        let copied = false;
        try {
          copied = document.execCommand("copy");
        } catch (_error) {
          copied = false;
        }
        document.body.removeChild(helper);
        flashCommandCopyHint(copied ? "Copied" : "Copy failed", copied);
      }

      async function pushLiveSettingsNow() {
        if (!shouldAllowLiveSettingsPush()) {
          return;
        }
        if (state.liveSettingsInFlight) {
          state.liveSettingsPending = true;
          updateLiveTuneIndicator();
          return;
        }

        const payload = buildLiveSettingsPayload();
        state.liveSettingsInFlight = true;
        updateLiveTuneIndicator();
        try {
          const result = await requestJSON("/api/live_settings", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          applyLiveSettingsFromServer(result.applied || null);
          flashLiveTuneSynced();
          if (result.status && typeof result.status === "object") {
            renderStatus(result.status);
          }
        } catch (error) {
          setError(error instanceof Error ? error.message : String(error));
        } finally {
          state.liveSettingsInFlight = false;
          if (state.liveSettingsPending) {
            state.liveSettingsPending = false;
            updateLiveTuneIndicator();
            window.setTimeout(() => {
              pushLiveSettingsNow();
            }, 0);
          } else {
            updateLiveTuneIndicator();
          }
        }
      }

      function scheduleLiveSettingsPush(immediate = false) {
        if (!shouldAllowLiveSettingsPush()) {
          return;
        }
        if (state.liveSettingsTimer !== null) {
          window.clearTimeout(state.liveSettingsTimer);
        }
        updateLiveTuneIndicator();
        state.liveSettingsTimer = window.setTimeout(() => {
          state.liveSettingsTimer = null;
          updateLiveTuneIndicator();
          pushLiveSettingsNow();
        }, immediate ? 0 : 140);
      }

      function syncSliderLabels() {
        ui.samplesValue.textContent = ui.samplesSlider.value;
        ui.depthValue.textContent = ui.depthSlider.value;
        ui.threadsValue.textContent = ui.threadsSlider.value;

        ui.liveSamplesValue.textContent = ui.liveSamplesSlider.value;
        ui.liveDepthValue.textContent = ui.liveDepthSlider.value;
        ui.liveIntervalValue.textContent = ui.liveIntervalSlider.value;
        ui.threadsValueLive.textContent = ui.threadsSliderLive.value;
      }

      function getSliderStep(slider) {
        const raw = slider.step;
        if (!raw || raw === "any") {
          return 1;
        }
        const value = Number(raw);
        if (!Number.isFinite(value) || value <= 0) {
          return 1;
        }
        return value;
      }

      function setSliderValue(slider, value) {
        const min = Number(slider.min);
        const max = Number(slider.max);
        const step = getSliderStep(slider);
        const stepPrecision = Math.max(0, String(step).split(".")[1]?.length || 0);

        let next = Number(value);
        if (!Number.isFinite(next)) {
          return false;
        }
        if (Number.isFinite(min)) {
          next = Math.max(min, next);
        }
        if (Number.isFinite(max)) {
          next = Math.min(max, next);
        }

        const base = Number.isFinite(min) ? min : 0;
        next = base + Math.round((next - base) / step) * step;
        if (Number.isFinite(min)) {
          next = Math.max(min, next);
        }
        if (Number.isFinite(max)) {
          next = Math.min(max, next);
        }

        slider.value = next.toFixed(stepPrecision);
        slider.dispatchEvent(new Event("input", { bubbles: true }));
        return true;
      }

      function bindSliderPrecisionControls() {
        const sliders = [
          ui.samplesSlider,
          ui.depthSlider,
          ui.threadsSlider,
          ui.liveSamplesSlider,
          ui.liveDepthSlider,
          ui.liveIntervalSlider,
          ui.threadsSliderLive,
          ui.zoomSlider,
        ];

        for (const slider of sliders) {
          slider.addEventListener("wheel", (event) => {
            if (slider.disabled) {
              return;
            }
            event.preventDefault();
            const step = getSliderStep(slider);
            const direction = event.deltaY < 0 ? 1 : -1;
            setSliderValue(slider, Number(slider.value) + direction * step);
          }, { passive: false });

          slider.addEventListener("dblclick", () => {
            if (slider.disabled) {
              return;
            }
            const label = document.querySelector('label[for="' + slider.id + '"]');
            const promptLabel = label ? label.textContent || slider.id : slider.id;
            const typed = window.prompt("Set " + promptLabel, slider.value);
            if (typed === null) {
              return;
            }
            setSliderValue(slider, Number(typed));
          });
        }
      }

      function bindInputPrecisionControls() {
        const numericInputs = Array.from(document.querySelectorAll('input.control-input[type="number"]'));
        for (const input of numericInputs) {
          if (!(input instanceof HTMLInputElement)) {
            continue;
          }

          input.addEventListener("focus", () => {
            if (!input.readOnly) {
              input.select();
            }
          });

          input.addEventListener("wheel", (event) => {
            if (input.disabled || document.activeElement !== input) {
              return;
            }
            event.preventDefault();
            const min = Number(input.min);
            const max = Number(input.max);
            const rawStep = input.step;
            const step = (!rawStep || rawStep === "any")
              ? 1
              : Math.max(1e-6, Number(rawStep) || 1);
            const precision = Math.max(0, String(step).split(".")[1]?.length || 0);
            const direction = event.deltaY < 0 ? 1 : -1;
            let next = Number(input.value);
            if (!Number.isFinite(next)) {
              next = Number.isFinite(min) ? min : 0;
            }
            next += direction * step;
            if (Number.isFinite(min)) {
              next = Math.max(min, next);
            }
            if (Number.isFinite(max)) {
              next = Math.min(max, next);
            }
            input.value = next.toFixed(precision);
            input.dispatchEvent(new Event("input", { bubbles: true }));
            input.dispatchEvent(new Event("change", { bubbles: true }));
          }, { passive: false });

          input.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              event.preventDefault();
              input.blur();
            }
          });
        }
      }

      function syncOutputFormatFromPath(persist = true) {
        const activePath = ui.modeSelect.value === "render"
          ? ui.outputInput.value
          : ui.liveOutputInput.value;
        const ext = extOf(activePath).replace(/^\./, "");
        if (OUTPUT_FORMATS.has(ext)) {
          ui.outputFormatSelect.value = ext;
        }
        if (persist) {
          persistUserPreferences();
        }
      }

      function applyOutputFormat(formatName) {
        const format = normalizeFormat(formatName);
        ui.outputInput.value = replaceExtension(ui.outputInput.value || "out/final.ppm", format);
        ui.liveOutputInput.value = replaceExtension(ui.liveOutputInput.value || "out/live_preview.ppm", format);
        persistUserPreferences();
      }

      function applyLiveProfile(profileName) {
        const profile = LIVE_PROFILES[profileName];
        if (!profile) {
          return;
        }

        ui.liveSamplesSlider.value = String(profile.liveSamples);
        ui.liveDepthSlider.value = String(profile.liveDepth);
        ui.liveIntervalSlider.value = String(profile.intervalMs);

        state.liveAdvanced.previewScale = profile.previewScale;
        state.liveAdvanced.previewSamples = profile.previewSamples;
        state.liveAdvanced.previewDepth = profile.previewDepth;
        state.liveAdvanced.refineEvery = profile.refineEvery;
        state.liveProfile = profileName;
        ui.liveProfileSelect.value = profileName;
        syncSliderLabels();
        persistUserPreferences();
      }

      function isSelectedDemoGpuCompatible() {
        const selected = ui.demoSelect.value;
        if (!selected) {
          return false;
        }
        if (Object.prototype.hasOwnProperty.call(state.demoGpuCompat, selected)) {
          return Boolean(state.demoGpuCompat[selected]);
        }
        return STATIC_GPU_DEMOS.has(selected);
      }

      function hasGpuCapableDemos() {
        for (const value of Object.values(state.demoGpuCompat)) {
          if (Boolean(value)) {
            return true;
          }
        }
        return Array.from(ui.demoSelect.options).some((option) => STATIC_GPU_DEMOS.has(option.value));
      }

      function updateDemoHint() {
        const selected = ui.demoSelect.value;
        const option = ui.demoSelect.options[ui.demoSelect.selectedIndex];
        const titleFromOption = option ? option.title : "";
        const description = state.demoDescriptions[selected] || titleFromOption || "";
        const compatText = isSelectedDemoGpuCompatible() ? "GPU-ready" : "CPU-only";
        const text = description
          ? description + " "
          : "No description available. ";
        ui.demoHint.textContent = "";
        ui.demoHint.appendChild(document.createTextNode(text));
        const compat = document.createElement("strong");
        compat.textContent = compatText;
        ui.demoHint.appendChild(compat);
      }

      function ensureGpuCompatibleDemoSelection() {
        if (ui.backendSelect.value !== "gpu") {
          return false;
        }
        if (isSelectedDemoGpuCompatible()) {
          return false;
        }

        const options = Array.from(ui.demoSelect.options);
        const fallback = options.find((option) => Boolean(state.demoGpuCompat[option.value]));
        if (!fallback) {
          return false;
        }

        ui.demoSelect.value = fallback.value;
        return true;
      }

      function markLiveProfileCustom() {
        if (ui.liveProfileSelect.value !== "custom") {
          ui.liveProfileSelect.value = "custom";
        }
        state.liveProfile = "custom";
        state.liveAdvanced.previewScale = 0.9;
        state.liveAdvanced.previewSamples = Math.max(
          6,
          Math.min(64, Math.floor(toInt(ui.liveSamplesSlider.value, 64) / 3))
        );
        state.liveAdvanced.previewDepth = Math.max(8, Math.min(14, toInt(ui.liveDepthSlider.value, 14)));
        state.liveAdvanced.refineEvery = 3;
        persistUserPreferences();
      }

      function updateModeVisibility() {
        const renderMode = ui.modeSelect.value === "render";
        for (const row of ui.modeRenderGroups) {
          row.classList.toggle("mode-hidden", !renderMode);
        }
        for (const row of ui.modeLiveGroups) {
          row.classList.toggle("mode-hidden", renderMode);
        }

        ui.app.classList.toggle("mode-render", renderMode);
        ui.app.classList.toggle("mode-live", !renderMode);
        syncOutputFormatFromPath();
      }

      function clampIntValue(rawValue, fallback, minimum, maximum) {
        const value = toInt(rawValue, fallback);
        return Math.round(clamp(value, minimum, maximum));
      }

      function normalizedOutputPath(pathText, fallback, format) {
        const trimmed = String(pathText || "").trim();
        const base = trimmed || fallback;
        const normalized = base.replace(/\\/g, "/");
        const unsafeAbsolute = normalized.startsWith("/") || /^[a-zA-Z]:\//.test(normalized);
        const unsafeTraversal = normalized.includes("../") || normalized === "..";
        const safePath = (unsafeAbsolute || unsafeTraversal) ? fallback : normalized;
        return replaceExtension(safePath, format);
      }

      function buildPayload() {
        const mode = ui.modeSelect.value;
        const outputFormat = normalizeFormat(ui.outputFormatSelect.value);
        const renderOutputFormat = outputFormat;
        let liveOutputFormat = outputFormat;
        if (!LIVE_ACCUM_FORMATS.has(liveOutputFormat)) {
          const currentLiveExt = extOf(ui.liveOutputInput.value).replace(/^\./, "");
          liveOutputFormat = LIVE_ACCUM_FORMATS.has(currentLiveExt) ? currentLiveExt : "ppm";
        }
        const width = clampIntValue(ui.widthInput.value, 1280, 64, 16384);
        const height = clampIntValue(ui.heightInput.value, 720, 64, 16384);
        const seed = clampIntValue(ui.seedInput.value, 7, 0, 2147483647);
        const threads = mode === "render"
          ? clampIntValue(ui.threadsSlider.value, 8, 1, MAX_UI_THREADS)
          : clampIntValue(ui.threadsSliderLive.value, 8, 1, MAX_UI_THREADS);

        ui.widthInput.value = String(width);
        ui.heightInput.value = String(height);
        ui.seedInput.value = String(seed);
        if (mode === "render") {
          ui.threadsSlider.value = String(threads);
          ui.threadsValue.textContent = ui.threadsSlider.value;
        } else {
          ui.threadsSliderLive.value = String(threads);
          ui.threadsValueLive.textContent = ui.threadsSliderLive.value;
        }

        const payload = {
          mode,
          demo: "scene_editor",
          backend: ui.backendSelect.value,
          width,
          height,
          threads,
          seed,
        };

        if (payload.demo === "scene_editor") {
          payload.scene_preset = state.scene.presetId || "editable";
          payload.scene_spec = encodeSceneSpec();
          payload.obj_path = sceneObjPathForRender();
          payload.camera_pos = [
            Number(state.camera.pos.x.toFixed(4)),
            Number(state.camera.pos.y.toFixed(4)),
            Number(state.camera.pos.z.toFixed(4)),
          ];
          payload.camera_yaw = Number(state.camera.yaw.toFixed(4));
          payload.camera_pitch = Number(state.camera.pitch.toFixed(4));
          payload.camera_fov = Number(state.camera.fov.toFixed(4));
        }

        if (mode === "render") {
          payload.samples = clampIntValue(ui.samplesSlider.value, 400, 1, 200000);
          payload.depth = clampIntValue(ui.depthSlider.value, 18, 1, 128);
          payload.output = normalizedOutputPath(ui.outputInput.value, "out/final.ppm", renderOutputFormat);
          ui.outputInput.value = payload.output;
        } else {
          payload.live_samples = clampIntValue(ui.liveSamplesSlider.value, 64, 1, 512);
          payload.live_depth = clampIntValue(ui.liveDepthSlider.value, 14, 1, 64);
          payload.live_interval_ms = clampIntValue(ui.liveIntervalSlider.value, 24, 0, 10000);
          payload.live_output = normalizedOutputPath(ui.liveOutputInput.value, "out/live_preview.ppm", liveOutputFormat);
          ui.liveOutputInput.value = payload.live_output;
          payload.live_add_to_recent = Boolean(ui.liveRecentToggle.checked);
          payload.live_profile = state.liveProfile || "speed";
          payload.live_preview_scale = state.liveAdvanced.previewScale;
          payload.live_preview_samples = state.liveAdvanced.previewSamples;
          payload.live_preview_depth = state.liveAdvanced.previewDepth;
          payload.live_refine_every = state.liveAdvanced.refineEvery;
        }

        return payload;
      }

      async function requestJSON(path, options = {}) {
        const response = await fetch(path, options);
        const raw = await response.text();
        let data = {};
        if (raw) {
          try {
            data = JSON.parse(raw);
          } catch (_error) {
            if (!response.ok) {
              const fallbackMessage = raw.trim()
                ? raw.trim().slice(0, 260)
                : ("HTTP " + response.status + " " + response.statusText);
              throw new Error(fallbackMessage);
            }
            throw new Error("Invalid JSON response from server.");
          }
        }
        if (!response.ok) {
          const rawMessage = typeof raw === "string" ? raw.trim() : "";
          const fallbackMessage = rawMessage
            ? rawMessage.slice(0, 260)
            : ("HTTP " + response.status + " " + response.statusText);
          const message = data && typeof data === "object" && typeof data.error === "string"
            ? data.error
            : fallbackMessage;
          throw new Error(message);
        }
        return data;
      }

      async function loadDemos() {
        try {
          const response = await requestJSON("/api/demos");
          const demos = Array.isArray(response.demos) ? response.demos : [];
          const liveProfiles = response.live_profiles && typeof response.live_profiles === "object"
            ? response.live_profiles
            : null;
          const defaultLiveProfile = typeof response.default_live_profile === "string"
            ? response.default_live_profile
            : "speed";

          if (liveProfiles) {
            for (const [name, values] of Object.entries(liveProfiles)) {
              if (!values || typeof values !== "object") {
                continue;
              }
              LIVE_PROFILES[name] = {
                liveSamples: toInt(values.live_samples, LIVE_PROFILES.balanced.liveSamples),
                liveDepth: toInt(values.live_depth, LIVE_PROFILES.balanced.liveDepth),
                intervalMs: toInt(values.live_interval_ms, LIVE_PROFILES.balanced.intervalMs),
                previewScale: toFloat(values.live_preview_scale, LIVE_PROFILES.balanced.previewScale),
                previewSamples: toInt(values.live_preview_samples, LIVE_PROFILES.balanced.previewSamples),
                previewDepth: toInt(values.live_preview_depth, LIVE_PROFILES.balanced.previewDepth),
                refineEvery: toInt(values.live_refine_every, LIVE_PROFILES.balanced.refineEvery),
              };
            }
          }

          if (LIVE_PROFILES[defaultLiveProfile]) {
            applyLiveProfile(defaultLiveProfile);
          }

          if (demos.length === 0) {
            return;
          }

          const wantedDefault = typeof response.default_demo === "string" ? response.default_demo : "scene_editor";
          const previous = ui.demoSelect.value;
          ui.demoSelect.innerHTML = "";
          state.demoGpuCompat = Object.create(null);
          state.demoDescriptions = Object.create(null);

          for (const demo of demos) {
            if (!demo || typeof demo.id !== "string") {
              continue;
            }
            const gpuCompat = Boolean(demo.gpu_compatible);
            state.demoGpuCompat[demo.id] = gpuCompat;
            const option = document.createElement("option");
            option.value = demo.id;
            const label = typeof demo.label === "string" ? demo.label : demo.id;
            option.textContent = label;
            if (typeof demo.description === "string") {
              state.demoDescriptions[demo.id] = demo.description;
              option.title = demo.description;
            }
            ui.demoSelect.appendChild(option);
          }

          if (ui.demoSelect.options.length === 0) {
            return;
          }

          const hasPrevious = Array.from(ui.demoSelect.options).some((opt) => opt.value === previous);
          const hasDefault = Array.from(ui.demoSelect.options).some((opt) => opt.value === wantedDefault);

          if (hasPrevious) {
            ui.demoSelect.value = previous;
          } else if (hasDefault) {
            ui.demoSelect.value = wantedDefault;
          } else {
            ui.demoSelect.selectedIndex = 0;
          }
          updateDemoHint();
          updateNavigationHint();
        } catch (_error) {
          // Keep static fallback options when endpoint is unavailable.
          updateDemoHint();
          updateNavigationHint();
        }
      }

      async function loadGpuProbe(force = false) {
        try {
          const endpoint = force ? "/api/gpu_probe?force=1" : "/api/gpu_probe";
          const response = await requestJSON(endpoint);
          const gpu = response && typeof response.gpu === "object" ? response.gpu : null;
          if (!gpu) {
            state.gpuProbeStatus = "unknown";
            state.gpuProbeMessage = "Invalid GPU probe response.";
          } else {
            state.gpuProbeStatus = typeof gpu.status === "string" ? gpu.status : "unknown";
            state.gpuProbeMessage = typeof gpu.message === "string" ? gpu.message : "GPU probe returned no message.";
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          if (message.toLowerCase().includes("endpoint not found")) {
            state.gpuProbeStatus = "unsupported";
            state.gpuProbeMessage = "GPU preflight endpoint not available.";
          } else {
            state.gpuProbeStatus = "failed";
            state.gpuProbeMessage = message;
          }
        }
        updateGpuWarning();
      }

      function persistPanelStates() {
        const payload = {};
        for (const toggle of ui.panelToggles) {
          const panel = toggle.closest(".panel");
          if (!panel || !panel.id) {
            continue;
          }
          payload[panel.id] = panel.classList.contains("is-collapsed");
        }
        safeSetStorage(PANEL_STATE_KEY, JSON.stringify(payload));
      }

      function restorePanelStates() {
        const raw = safeGetStorage(PANEL_STATE_KEY);
        if (!raw) {
          return;
        }

        try {
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== "object") {
            return;
          }

          for (const toggle of ui.panelToggles) {
            const panel = toggle.closest(".panel");
            if (!panel || !panel.id) {
              continue;
            }
            const collapsed = Boolean(parsed[panel.id]);
            panel.classList.toggle("is-collapsed", collapsed);
            toggle.setAttribute("aria-expanded", String(!collapsed));
          }
        } catch (_error) {
          // Ignore malformed saved panel state.
        }
      }

      function clearNode(node) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
      }

      function outputsToSignature(list) {
        return list.join("\n");
      }

      function markActiveOutputItem(activeOutput) {
        const items = ui.fileList.querySelectorAll(".file-item");
        for (const item of items) {
          if (!(item instanceof HTMLElement)) {
            continue;
          }
          const outputName = item.getAttribute("data-output") || "";
          item.classList.toggle("active", outputName === activeOutput);
        }
      }

      function clonePayload(payload) {
        return JSON.parse(JSON.stringify(payload));
      }

      function rememberOutputSettings(outputName, payload) {
        if (!outputName || !payload || typeof payload !== "object") {
          return;
        }
        state.outputConfigByName[outputName] = clonePayload(payload);
      }

      function restoreOutputSettings(outputName) {
        if (!outputName || state.running) {
          return;
        }

        const payload = state.outputConfigByName[outputName];
        if (!payload || typeof payload !== "object") {
          return;
        }

        const mode = payload.mode === "render" ? "render" : "live";
        ui.modeSelect.value = mode;

        if (typeof payload.demo === "string") {
          const canSetDemo = Array.from(ui.demoSelect.options).some((option) => option.value === payload.demo);
          if (canSetDemo) {
            ui.demoSelect.value = payload.demo;
          }
        }

        if (typeof payload.backend === "string") {
          const canSetBackend = Array.from(ui.backendSelect.options).some((option) => option.value === payload.backend);
          if (canSetBackend) {
            ui.backendSelect.value = payload.backend;
          }
        }

        if (typeof payload.scene_preset === "string") {
          const normalizedPreset = normalizeScenePresetId(payload.scene_preset);
          state.scene.presetId = normalizedPreset;
          if (ui.demoPresetSelect) {
            ui.demoPresetSelect.value = normalizedPreset;
          }
        }

        if (typeof payload.obj_path === "string") {
          state.scene.objPath = payload.obj_path.trim();
          state.scene.objName = outputNameFromPathText(state.scene.objPath);
          setObjSceneEnabled(Boolean(state.scene.objPath), false);
        }

        if (Number.isFinite(Number(payload.width))) {
          ui.widthInput.value = String(payload.width);
        }
        if (Number.isFinite(Number(payload.height))) {
          ui.heightInput.value = String(payload.height);
        }
        if (Number.isFinite(Number(payload.seed))) {
          ui.seedInput.value = String(payload.seed);
        }

        if (mode === "render") {
          if (Number.isFinite(Number(payload.samples))) {
            ui.samplesSlider.value = String(payload.samples);
          }
          if (Number.isFinite(Number(payload.depth))) {
            ui.depthSlider.value = String(payload.depth);
          }
          if (Number.isFinite(Number(payload.threads))) {
            ui.threadsSlider.value = String(clampIntValue(payload.threads, 8, 1, MAX_UI_THREADS));
          }
          if (typeof payload.output === "string" && payload.output.trim()) {
            ui.outputInput.value = payload.output;
          }
        } else {
          if (Number.isFinite(Number(payload.live_samples))) {
            ui.liveSamplesSlider.value = String(payload.live_samples);
          }
          if (Number.isFinite(Number(payload.live_depth))) {
            ui.liveDepthSlider.value = String(payload.live_depth);
          }
          if (Number.isFinite(Number(payload.live_interval_ms))) {
            ui.liveIntervalSlider.value = String(payload.live_interval_ms);
          }
          if (Number.isFinite(Number(payload.threads))) {
            ui.threadsSliderLive.value = String(clampIntValue(payload.threads, 8, 1, MAX_UI_THREADS));
          }
          if (typeof payload.live_output === "string" && payload.live_output.trim()) {
            ui.liveOutputInput.value = payload.live_output;
          }
          if (typeof payload.live_add_to_recent === "boolean") {
            ui.liveRecentToggle.checked = payload.live_add_to_recent;
          }

          if (typeof payload.live_profile === "string") {
            const canSetProfile = Array.from(ui.liveProfileSelect.options).some((option) => option.value === payload.live_profile);
            ui.liveProfileSelect.value = canSetProfile ? payload.live_profile : "custom";
            state.liveProfile = ui.liveProfileSelect.value;
          } else {
            markLiveProfileCustom();
          }
        }

        if (typeof payload.scene_spec === "string") {
          state.scene.objects = decodeSceneSpec(payload.scene_spec);
          updateSceneCounterFromExisting();
          setSceneSelection(state.scene.objects[0] ? state.scene.objects[0].id : "");
          state.scene.lastSentSpec = "";
          state.scene.lastSentObjPath = "";
        }

        if (Array.isArray(payload.camera_pos) && payload.camera_pos.length === 3) {
          state.camera.pos.x = toFloat(payload.camera_pos[0], state.camera.pos.x);
          state.camera.pos.y = toFloat(payload.camera_pos[1], state.camera.pos.y);
          state.camera.pos.z = toFloat(payload.camera_pos[2], state.camera.pos.z);
        }
        if (Number.isFinite(Number(payload.camera_yaw))) {
          state.camera.yaw = toFloat(payload.camera_yaw, state.camera.yaw);
        }
        if (Number.isFinite(Number(payload.camera_pitch))) {
          state.camera.pitch = clamp(toFloat(payload.camera_pitch, state.camera.pitch), -89, 89);
        }
        if (Number.isFinite(Number(payload.camera_fov))) {
          state.camera.fov = clamp(toFloat(payload.camera_fov, state.camera.fov), 20, 100);
        }

        syncSliderLabels();
        updateModeVisibility();
        syncOutputFormatFromPath();
        updateDemoHint();
        updateNavigationHint();
        renderViewport();
      }

      function hideHoverPreview() {
        ui.thumbHoverPreview.classList.remove("visible");
        state.hoverOutputName = "";
      }

      function moveHoverPreview(clientX, clientY) {
        const offsetX = 16;
        const offsetY = 16;
        const maxLeft = Math.max(8, window.innerWidth - ui.thumbHoverPreview.offsetWidth - 8);
        const maxTop = Math.max(8, window.innerHeight - ui.thumbHoverPreview.offsetHeight - 8);
        const left = Math.min(maxLeft, Math.max(8, clientX + offsetX));
        const top = Math.min(maxTop, Math.max(8, clientY + offsetY));
        ui.thumbHoverPreview.style.left = String(left) + "px";
        ui.thumbHoverPreview.style.top = String(top) + "px";
      }

      function showHoverPreview(outputName, clientX, clientY) {
        const extension = extOf(outputName);
        if (!(DISPLAYABLE_EXT.has(extension) || extension === ".ppm")) {
          hideHoverPreview();
          return;
        }

        if (state.hoverOutputName !== outputName) {
          state.hoverOutputName = outputName;
          ui.thumbHoverImage.src = "/output/" + encodeURIComponent(outputName) + "?hover=" + state.thumbRevision;
          ui.thumbHoverLabel.textContent = outputName;
        }

        moveHoverPreview(clientX, clientY);
        ui.thumbHoverPreview.classList.add("visible");
      }

      function liveOutputNamesToHide(status = null) {
        if (ui.liveRecentToggle.checked) {
          return new Set();
        }
        const hidden = new Set();
        const configured = outputNameFromPath(ui.liveOutputInput.value);
        if (configured) {
          hidden.add(configured);
        }
        if (status && status.mode === "live" && typeof status.last_output === "string" && status.last_output) {
          hidden.add(status.last_output);
        }
        return hidden;
      }

      function renderOutputs(outputs, status = null) {
        const all = Array.isArray(outputs)
          ? outputs.filter((name) => typeof name === "string" && name.length > 0)
          : [];
        const hidden = liveOutputNamesToHide(status || state.lastStatus || null);
        const filtered = all.filter((name) => !hidden.has(name));
        const list = filtered.slice(0, 3);

        state.currentOutputs = list;

        if (state.selectedOutput && !list.includes(state.selectedOutput)) {
          state.selectedOutput = "";
        }

        if (list.length === 0) {
          state.outputsSignature = "";
          const empty = document.createElement("div");
          empty.className = "empty-state";
          empty.textContent = "No outputs yet";
          clearNode(ui.fileList);
          ui.fileList.appendChild(empty);
          return;
        }

        const lastOutput = state.lastStatus && typeof state.lastStatus.last_output === "string"
          ? state.lastStatus.last_output
          : "";
        const activeOutputCandidate = state.selectedOutput || lastOutput || list[0];
        const activeOutput = list.includes(activeOutputCandidate) ? activeOutputCandidate : list[0];
        const nextSignature = outputsToSignature(list);

        if (nextSignature === state.outputsSignature) {
          markActiveOutputItem(activeOutput);
          return;
        }

        state.outputsSignature = nextSignature;
        state.thumbRevision += 1;
        clearNode(ui.fileList);

        for (let i = 0; i < list.length; i += 1) {
          const name = list[i];
          const extension = extOf(name);

          const item = document.createElement("button");
          item.type = "button";
          item.className = "file-item";
          item.setAttribute("data-output", name);
          if (name === activeOutput) {
            item.classList.add("active");
          }

          const thumb = document.createElement("div");
          thumb.className = "file-thumb";

          if (DISPLAYABLE_EXT.has(extension) || extension === ".ppm") {
            const image = document.createElement("img");
            image.loading = "lazy";
            image.alt = name;
            image.src = "/output/" + encodeURIComponent(name) + "?thumb=" + state.thumbRevision;
            image.addEventListener("error", () => {
              thumb.textContent = (extension || ".file").replace(".", "").toUpperCase();
            });
            thumb.appendChild(image);
          } else {
            thumb.textContent = (extension || ".file").replace(".", "").toUpperCase();
          }

          const meta = document.createElement("div");
          meta.className = "file-meta-block";

          const fileName = document.createElement("span");
          fileName.className = "file-name";
          fileName.textContent = name;

          const fileMeta = document.createElement("span");
          fileMeta.className = "file-meta";
          fileMeta.textContent = i === 0 ? "latest" : (extension.replace(".", "") || "file");

          meta.appendChild(fileName);
          meta.appendChild(fileMeta);

          item.appendChild(thumb);
          item.appendChild(meta);

          item.addEventListener("click", () => {
            restoreOutputSettings(name);
            state.selectedOutput = name;
            renderOutputs(state.currentOutputs, state.lastStatus || null);
            renderPreview(state.lastStatus || { last_output: name, outputs: state.currentOutputs, running: false });
          });
          item.addEventListener("mouseenter", (event) => {
            showHoverPreview(name, event.clientX, event.clientY);
          });
          item.addEventListener("mousemove", (event) => {
            moveHoverPreview(event.clientX, event.clientY);
          });
          item.addEventListener("mouseleave", hideHoverPreview);
          item.addEventListener("blur", hideHoverPreview);

          ui.fileList.appendChild(item);
        }
      }

      function hasPreviewImage() {
        return ui.previewImage.complete && ui.previewImage.naturalWidth > 0 && ui.previewImage.naturalHeight > 0;
      }

      function hasSampleFrame() {
        return Boolean(state.sampleCtx) && ui.sampleCanvas.width > 0 && ui.sampleCanvas.height > 0;
      }

      function viewportFrameSource() {
        if (hasPreviewImage()) {
          return ui.previewImage;
        }
        if (hasSampleFrame()) {
          return ui.sampleCanvas;
        }
        return null;
      }

      function viewportFrameSize() {
        if (hasPreviewImage()) {
          return { width: ui.previewImage.naturalWidth, height: ui.previewImage.naturalHeight };
        }
        if (hasSampleFrame()) {
          return { width: ui.sampleCanvas.width, height: ui.sampleCanvas.height };
        }
        return null;
      }

      function ensureCanvasSize() {
        const rect = ui.viewport.getBoundingClientRect();
        const width = Math.max(1, rect.width);
        const height = Math.max(1, rect.height);
        const dpr = window.devicePixelRatio || 1;
        const targetWidth = Math.max(1, Math.round(width * dpr));
        const targetHeight = Math.max(1, Math.round(height * dpr));

        if (ui.previewCanvas.width !== targetWidth || ui.previewCanvas.height !== targetHeight) {
          ui.previewCanvas.width = targetWidth;
          ui.previewCanvas.height = targetHeight;
        }

        return { width, height, dpr };
      }

      function getBaseScale(viewWidth, viewHeight, imageWidth, imageHeight) {
        if (ui.fitModeSelect.value === "cover") {
          return Math.max(viewWidth / imageWidth, viewHeight / imageHeight);
        }
        return Math.min(viewWidth / imageWidth, viewHeight / imageHeight);
      }

      function getViewportGeometry(viewWidth, viewHeight) {
        const size = viewportFrameSize();
        if (!size) {
          return null;
        }

        const imageWidth = size.width;
        const imageHeight = size.height;
        const baseScale = getBaseScale(viewWidth, viewHeight, imageWidth, imageHeight);
        const scale = baseScale * state.zoom;

        const drawWidth = imageWidth * scale;
        const drawHeight = imageHeight * scale;
        const drawX = viewWidth / 2 + state.panX - drawWidth / 2;
        const drawY = viewHeight / 2 + state.panY - drawHeight / 2;

        return {
          imageWidth,
          imageHeight,
          scale,
          drawWidth,
          drawHeight,
          drawX,
          drawY,
        };
      }

      function clampPan(viewWidth, viewHeight) {
        if (state.zoom <= 1.001) {
          state.panX = 0;
          state.panY = 0;
          return;
        }

        const geom = getViewportGeometry(viewWidth, viewHeight);
        if (!geom) {
          state.panX = 0;
          state.panY = 0;
          return;
        }

        const maxPanX = Math.max(0, (geom.drawWidth - viewWidth) / 2);
        const maxPanY = Math.max(0, (geom.drawHeight - viewHeight) / 2);

        state.panX = Math.max(-maxPanX, Math.min(maxPanX, state.panX));
        state.panY = Math.max(-maxPanY, Math.min(maxPanY, state.panY));
      }

      function renderViewport() {
        const { width, height, dpr } = ensureCanvasSize();
        const ctx = ui.previewCanvas.getContext("2d");
        if (!ctx) {
          return;
        }

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, width, height);

        const source = viewportFrameSource();
        const geom = source ? getViewportGeometry(width, height) : null;
        if (source && geom) {
          ctx.imageSmoothingEnabled = true;
          ctx.drawImage(source, geom.drawX, geom.drawY, geom.drawWidth, geom.drawHeight);
        }

        ui.zoomValue.textContent = String(Math.round(state.zoom * 100)) + "%";
        ui.zoomSlider.value = String(Math.round(state.zoom * 100));

        ui.viewport.classList.toggle("can-pan", state.zoom > 1.001 && Boolean(source));
        updateGizmoOverlay();
      }

      function updateSampleCanvas() {
        if (!hasPreviewImage()) {
          state.sampleCtx = null;
          return;
        }

        const width = ui.previewImage.naturalWidth;
        const height = ui.previewImage.naturalHeight;

        ui.sampleCanvas.width = width;
        ui.sampleCanvas.height = height;

        const sampleCtx = ui.sampleCanvas.getContext("2d", { willReadFrequently: true });
        if (!sampleCtx) {
          state.sampleCtx = null;
          return;
        }

        sampleCtx.clearRect(0, 0, width, height);
        sampleCtx.drawImage(ui.previewImage, 0, 0);
        state.sampleCtx = sampleCtx;
      }

      function clearPixelReadout() {
        ui.pixelCoord.textContent = "X:- Y:-";
        ui.pixelValue.textContent = "R:- G:- B:-";
      }

      function updatePixelReadout(clientX, clientY) {
        if (!hasPreviewImage() || !state.sampleCtx) {
          clearPixelReadout();
          return;
        }

        const rect = ui.viewport.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        if (x < 0 || y < 0 || x > rect.width || y > rect.height) {
          clearPixelReadout();
          return;
        }

        const geom = getViewportGeometry(rect.width, rect.height);
        if (!geom) {
          clearPixelReadout();
          return;
        }

        const imageX = (x - geom.drawX) / geom.scale;
        const imageY = (y - geom.drawY) / geom.scale;

        if (imageX < 0 || imageY < 0 || imageX >= geom.imageWidth || imageY >= geom.imageHeight) {
          clearPixelReadout();
          return;
        }

        const px = Math.max(0, Math.min(geom.imageWidth - 1, Math.floor(imageX)));
        const py = Math.max(0, Math.min(geom.imageHeight - 1, Math.floor(imageY)));

        const pixel = state.sampleCtx.getImageData(px, py, 1, 1).data;
        ui.pixelCoord.textContent = "X:" + px + " Y:" + py;
        ui.pixelValue.textContent = "R:" + pixel[0] + " G:" + pixel[1] + " B:" + pixel[2];
      }

      function setZoom(nextZoom, anchorClientX = null, anchorClientY = null) {
        const newZoom = Math.max(state.minZoom, Math.min(state.maxZoom, nextZoom));

        const rect = ui.viewport.getBoundingClientRect();
        const viewWidth = Math.max(1, rect.width);
        const viewHeight = Math.max(1, rect.height);

        const oldGeom = getViewportGeometry(viewWidth, viewHeight);

        if (!oldGeom) {
          state.zoom = newZoom;
          state.panX = 0;
          state.panY = 0;
          renderViewport();
          return;
        }

        const anchorX = typeof anchorClientX === "number" ? anchorClientX - rect.left : viewWidth / 2;
        const anchorY = typeof anchorClientY === "number" ? anchorClientY - rect.top : viewHeight / 2;

        const imageX = (anchorX - oldGeom.drawX) / oldGeom.scale;
        const imageY = (anchorY - oldGeom.drawY) / oldGeom.scale;

        state.zoom = newZoom;

        const baseScale = getBaseScale(viewWidth, viewHeight, oldGeom.imageWidth, oldGeom.imageHeight);
        const newScale = baseScale * state.zoom;

        state.panX = anchorX - viewWidth / 2 + newScale * (oldGeom.imageWidth / 2 - imageX);
        state.panY = anchorY - viewHeight / 2 + newScale * (oldGeom.imageHeight / 2 - imageY);

        clampPan(viewWidth, viewHeight);
        renderViewport();
      }

      function resetView() {
        state.zoom = 1;
        state.panX = 0;
        state.panY = 0;
        renderViewport();
      }

      async function toggleFullscreen() {
        try {
          if (document.fullscreenElement) {
            await document.exitFullscreen();
          } else if (ui.viewportStage.requestFullscreen) {
            await ui.viewportStage.requestFullscreen();
          }
        } catch (_error) {
          // Browser may reject fullscreen without direct user gesture.
        }
      }

      function pickPreviewOutput(status) {
        const outputs = Array.isArray(status.outputs) ? status.outputs : state.currentOutputs;
        if (state.selectedOutput && outputs.includes(state.selectedOutput)) {
          return state.selectedOutput;
        }
        if (typeof status.last_output === "string" && status.last_output.length > 0) {
          return status.last_output;
        }
        if (outputs.length > 0) {
          return outputs[0];
        }
        return "";
      }

      function setPreviewUnavailable(message, output = "") {
        ui.previewCanvas.style.display = "none";
        ui.previewPlaceholder.style.display = "grid";
        ui.placeholderText.textContent = message;
        ui.hudResolutionValue.textContent = "-";
        ui.hudSummaryValue.textContent = "-";
        ui.hudOutputValue.textContent = output || "-";
        state.previewKey = "";
        state.previewOutput = "";
        state.previewImageLoading = false;
        state.queuedPreview = null;
        state.sampleCtx = null;
        state.sampleRefreshAtMs = 0;
        ui.sampleCanvas.width = 0;
        ui.sampleCanvas.height = 0;
        clearPixelReadout();
        updateGizmoOverlay();
      }

      function loadPreviewImageSource(source, output, key) {
        state.previewKey = key;
        state.previewOutput = output;
        state.previewFallbackTried = false;
        state.previewImageLoading = true;
        const sep = source.includes("?") ? "&" : "?";
        ui.previewImage.src = source + sep + "t=" + Date.now();
      }

      function flushQueuedPreviewImage() {
        if (state.previewImageLoading || !state.queuedPreview) {
          return;
        }
        const queued = state.queuedPreview;
        state.queuedPreview = null;
        loadPreviewImageSource(queued.source, queued.output, queued.key);
      }

      function renderPreview(status) {
        const output = pickPreviewOutput(status);

        if (!output) {
          setPreviewUnavailable("Run a render to preview output.");
          return;
        }

        const extension = extOf(output);
        let source = "";

        if (extension === ".ppm") {
          source = "/api/preview.bmp?output=" + encodeURIComponent(output);
        } else if (DISPLAYABLE_EXT.has(extension)) {
          source = "/output/" + encodeURIComponent(output);
        }

        if (!source) {
          setPreviewUnavailable("Preview unavailable for " + (extension || "this file type") + ".", output);
          return;
        }

        ui.hudOutputValue.textContent = output;
        ui.previewPlaceholder.style.display = "none";
        ui.previewCanvas.style.display = "block";

        const refreshTick = status.running
          ? (
            Number.isFinite(Number(status.live_frame))
              ? "frame-" + String(Number(status.live_frame))
              : String(Date.now())
          )
          : "stable";
        const nextKey = source + "|" + refreshTick;

        if (nextKey !== state.previewKey || state.previewOutput !== output) {
          if (state.previewImageLoading) {
            state.queuedPreview = { source, output, key: nextKey };
          } else {
            loadPreviewImageSource(source, output, nextKey);
          }
        }
      }

      function renderStatus(status) {
        state.lastStatus = status;

        const running = Boolean(status.running);
        const mode = typeof status.mode === "string" ? status.mode : "live";
        const demo = "scene_editor";
        const phase = typeof status.live_phase === "string" ? status.live_phase : "-";
        const statusLiveProfile = typeof status.live_profile === "string" ? status.live_profile : "";
        const localLiveProfile = state.liveProfile || ui.liveProfileSelect.value || "speed";
        const liveProfile = running && statusLiveProfile ? statusLiveProfile : localLiveProfile;
        const backendRequested = typeof status.backend_requested === "string"
          ? status.backend_requested
          : (ui.backendSelect.value || "auto");
        const backendActive = typeof status.backend_active === "string"
          ? status.backend_active
          : "unknown";
        const lastOutputName = typeof status.last_output === "string" ? status.last_output : "";
        const statusObjPath = typeof status.obj_path === "string" ? status.obj_path : null;

        if (state.pendingPayload && lastOutputName) {
          rememberOutputSettings(lastOutputName, state.pendingPayload);
          state.pendingPayload = null;
        }

        if (statusObjPath !== null && statusObjPath !== state.scene.objPath) {
          state.scene.objPath = statusObjPath;
          state.scene.objName = outputNameFromPathText(statusObjPath);
          setObjSceneEnabled(Boolean(statusObjPath), false);
        } else if (statusObjPath !== null) {
          setObjSceneEnabled(Boolean(statusObjPath), false);
        }

        const liveFps = Number(status.live_fps);
        const fpsText = Number.isFinite(liveFps) && liveFps > 0 ? liveFps.toFixed(1) : "-";

        const frameMs = Number(status.live_last_frame_ms);
        const frameMsText = Number.isFinite(frameMs) && frameMs > 0 ? frameMs.toFixed(0) + "ms" : "-";

        const hasError = typeof status.last_error === "string" && status.last_error.trim().length > 0;
        const hasGpuWarning = hasGpuCapableDemos()
          && !running
          && ui.backendSelect.value === "gpu"
          && state.gpuProbeStatus !== "ok";

        ui.app.classList.remove("state-idle", "state-running", "state-warn", "state-error");
        if (hasError) {
          ui.app.classList.add("state-error");
        } else if (running) {
          ui.app.classList.add("state-running");
        } else if (hasGpuWarning) {
          ui.app.classList.add("state-warn");
        } else {
          ui.app.classList.add("state-idle");
        }

        ui.stateDot.classList.remove("running", "warn", "error");
        ui.stateText.classList.remove("state-running", "state-warn", "state-error");
        if (hasError) {
          ui.stateDot.classList.add("error");
          ui.stateText.classList.add("state-error");
        } else if (running) {
          ui.stateDot.classList.add("running");
          ui.stateText.classList.add("state-running");
        } else if (hasGpuWarning) {
          ui.stateDot.classList.add("warn");
          ui.stateText.classList.add("state-warn");
        }

        ui.stateText.textContent = running
          ? (mode === "live" ? "Rendering (Live)" : "Rendering")
          : "Idle";
        const backendDisplay = backendActive !== "unknown"
          ? backendActive.toUpperCase()
          : backendRequested.toUpperCase();
        ui.backendText.textContent = backendDisplay;
        ui.backendText.classList.remove("backend-gpu");
        const backendTone = (backendActive !== "unknown" ? backendActive : backendRequested).toLowerCase();
        if (backendTone === "gpu") {
          ui.backendText.classList.add("backend-gpu");
        }
        ui.durationText.textContent = formatDuration(status.duration_sec);

        const activeSamples = mode === "render"
          ? ui.samplesSlider.value
          : String(Number(status.live_preview_samples) || ui.liveSamplesSlider.value);

        if (running && mode === "live" && fpsText !== "-") {
          ui.samplesText.textContent = activeSamples + " @ " + fpsText + "fps";
        } else {
          ui.samplesText.textContent = running ? activeSamples : (status.last_output ? activeSamples : "-");
        }

        ui.hudSamplesValue.textContent = running ? activeSamples : "-";
        ui.hudTimeValue.textContent = formatDuration(status.duration_sec);
        ui.hudResolutionValue.textContent = ui.widthInput.value + "x" + ui.heightInput.value;
        ui.hudSummaryValue.textContent =
          ui.widthInput.value + "x" + ui.heightInput.value +
          " | Samples " + (running ? activeSamples : "-") +
          " | Time " + formatDuration(status.duration_sec) +
          " | " + backendDisplay;

        ui.detailMode.textContent = mode;
        ui.detailDemo.textContent = formatEnvironmentName(demo);
        if (backendActive !== "unknown" && backendActive !== backendRequested) {
          ui.detailBackend.textContent = backendActive + " (req " + backendRequested + ")";
        } else {
          ui.detailBackend.textContent = backendActive !== "unknown" ? backendActive : backendRequested;
        }
        ui.detailProfile.textContent = mode === "live" ? liveProfile : "-";
        ui.detailPhase.textContent = mode === "live" ? phase : "-";
        ui.detailFps.textContent = mode === "live" ? (fpsText + " / " + frameMsText) : "-";
        ui.detailState.textContent = running ? "running" : "idle";
        ui.detailFrames.textContent = String(status.live_frame || 0);
        ui.detailExit.textContent = status.last_return_code === null || status.last_return_code === undefined
          ? "-"
          : String(status.last_return_code);

        ui.commandText.textContent = Array.isArray(status.command) && status.command.length > 0
          ? status.command.join(" ")
          : "No active command";

        if (demo && ui.demoSelect.value !== demo) {
          const canSetDemo = Array.from(ui.demoSelect.options).some((option) => option.value === demo);
          if (canSetDemo) {
            ui.demoSelect.value = demo;
          }
        }
        updateDemoHint();
        updateGizmoOverlay();

        if (mode === "live" && running && statusLiveProfile) {
          state.liveProfile = statusLiveProfile;
          const canSetProfile = Array.from(ui.liveProfileSelect.options).some((option) => option.value === statusLiveProfile);
          ui.liveProfileSelect.value = canSetProfile ? statusLiveProfile : "custom";
        }

        if (Number.isFinite(Number(status.scene_revision))) {
          state.scene.sceneRevision = Number(status.scene_revision);
        }
        applyCameraStatus(status);
        updateNavigationHint();

        setRunningState(running, mode);
        setError(status.last_error || "");
        renderTelemetry(status);
        updateLiveTuneIndicator();

        const navigating = state.camera.lookActive || cameraInputActive();
        if (ui.autoRefreshToggle.checked || !running || navigating) {
          if (!running || !navigating) {
            renderOutputs(status.outputs || [], status);
          }
          renderPreview(status);
        }
      }

      function statusPollIntervalMs() {
        if (!state.running || ui.modeSelect.value !== "live") {
          return 180;
        }
        if (state.camera.lookActive || cameraInputActive()) {
          return 16;
        }
        if (isLiveSceneNavigationEnabled()) {
          return 24;
        }
        return 40;
      }

      function ensureStatusPolling(forceRestart = false) {
        const nextMs = statusPollIntervalMs();
        if (!forceRestart && state.pollHandle !== null && state.pollIntervalMs === nextMs) {
          return;
        }
        if (state.pollHandle !== null) {
          window.clearInterval(state.pollHandle);
        }
        state.pollHandle = window.setInterval(refreshStatus, nextMs);
        state.pollIntervalMs = nextMs;
      }

      async function refreshStatus() {
        if (state.statusPollInFlight) {
          state.statusPollPending = true;
          return;
        }
        state.statusPollInFlight = true;
        try {
          const data = await requestJSON("/api/status");
          renderStatus(data.status || {});
        } catch (error) {
          setError(error instanceof Error ? error.message : String(error));
        } finally {
          state.statusPollInFlight = false;
          ensureStatusPolling();
          if (state.statusPollPending) {
            state.statusPollPending = false;
            window.setTimeout(() => {
              refreshStatus();
            }, 0);
          }
        }
      }

      async function startRender() {
        if (ui.backendSelect.value === "gpu") {
          if (state.gpuProbeStatus === "unknown") {
            await loadGpuProbe(true);
          }
          if (state.gpuProbeStatus === "failed" || state.gpuProbeStatus === "unavailable") {
            setError(
              "GPU preflight failed: " + state.gpuProbeMessage +
              " | Attempting GPU render anyway."
            );
          }
        }

        const payload = buildPayload();
        state.pendingPayload = clonePayload(payload);

        try {
          setError("");
          const result = await requestJSON("/api/run", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          state.selectedOutput = "";
          renderStatus(result.status || {});
          closeDrawers();
        } catch (error) {
          state.pendingPayload = null;
          setError(error instanceof Error ? error.message : String(error));
        }
      }

      async function stopRender() {
        try {
          setError("");
          const result = await requestJSON("/api/stop", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: "{}",
          });
          renderStatus(result.status || {});
        } catch (error) {
          setError(error instanceof Error ? error.message : String(error));
        }
      }

      function bindPanelToggles() {
        for (const toggle of ui.panelToggles) {
          toggle.addEventListener("click", () => {
            const panel = toggle.closest(".panel");
            if (!panel) {
              return;
            }

            panel.classList.toggle("is-collapsed");
            const expanded = !panel.classList.contains("is-collapsed");
            toggle.setAttribute("aria-expanded", String(expanded));
            persistPanelStates();
          });
        }
      }

      function bindViewportEvents() {
        ui.previewImage.addEventListener("load", () => {
          ui.previewCanvas.style.display = "block";
          ui.previewPlaceholder.style.display = "none";
          state.previewImageLoading = false;
          state.previewFallbackTried = false;
          ui.hudResolutionValue.textContent =
            String(ui.previewImage.naturalWidth) + "x" + String(ui.previewImage.naturalHeight);
          const nowMs = performance.now();
          const navigating = state.camera.lookActive || cameraInputActive();
          if (!navigating || (nowMs - state.sampleRefreshAtMs) >= 220) {
            updateSampleCanvas();
            state.sampleRefreshAtMs = nowMs;
          }
          renderViewport();
          flushQueuedPreviewImage();
        });

        ui.previewImage.addEventListener("error", () => {
          const extension = extOf(state.previewOutput);
          if (extension === ".ppm" && !state.previewFallbackTried) {
            state.previewFallbackTried = true;
            const outputQuery = state.previewOutput
              ? ("&output=" + encodeURIComponent(state.previewOutput))
              : "";
            ui.previewImage.src = "/api/preview.bmp?t=" + Date.now() + outputQuery;
            return;
          }

          setPreviewUnavailable("Failed to load preview image.", state.previewOutput);
          state.previewImageLoading = false;
          flushQueuedPreviewImage();
        });

        ui.zoomSlider.addEventListener("input", () => {
          const next = Number(ui.zoomSlider.value) / 100;
          setZoom(next);
        });

        ui.resetViewBtn.addEventListener("click", resetView);
        ui.fullscreenBtn.addEventListener("click", toggleFullscreen);

        ui.viewport.addEventListener("wheel", (event) => {
          if (!hasPreviewImage()) {
            return;
          }
          event.preventDefault();
          const factor = event.deltaY < 0 ? 1.1 : 0.9;
          setZoom(state.zoom * factor, event.clientX, event.clientY);
          updatePixelReadout(event.clientX, event.clientY);
        }, { passive: false });

        ui.viewport.addEventListener("contextmenu", (event) => {
          if (isLiveSceneNavigationEnabled()) {
            event.preventDefault();
          }
        });

        ui.viewport.addEventListener("pointerdown", (event) => {
          if (event.button === 2 && isLiveSceneNavigationEnabled()) {
            event.preventDefault();
            beginCameraLook(event.clientX, event.clientY);
            ui.viewport.setPointerCapture(event.pointerId);
            return;
          }

          if (!hasPreviewImage()) {
            return;
          }

          if (isSceneEditorDemo()) {
            if (event.button === 0 && !event.altKey) {
              const pickedId = pickSceneObjectAt(event.clientX, event.clientY);
              const sameSelection = pickedId && pickedId === state.scene.selectedId;
              if ((event.shiftKey || sameSelection) && pickedId) {
                setSceneSelection(pickedId);
                beginSceneDrag(event.clientX, event.clientY);
                ui.viewport.setPointerCapture(event.pointerId);
                return;
              }
              state.scene.clickCandidate = {
                pointerId: event.pointerId,
                x: event.clientX,
                y: event.clientY,
                pickedId,
              };
              if (pickedId) {
                setSceneSelection(pickedId);
              }
              ui.viewport.setPointerCapture(event.pointerId);
              return;
            }
            if (event.button !== 1 && !(event.button === 0 && event.altKey)) {
              return;
            }
          } else if (event.button !== 0) {
            return;
          }

          state.dragging = true;
          state.dragLastX = event.clientX;
          state.dragLastY = event.clientY;
          ui.viewport.classList.add("is-dragging");
          ui.viewport.setPointerCapture(event.pointerId);
        });

        ui.viewport.addEventListener("pointermove", (event) => {
          updatePixelReadout(event.clientX, event.clientY);

          if (state.camera.lookActive) {
            updateCameraLook(event.clientX, event.clientY);
            renderViewport();
            return;
          }

          if (state.scene.drag) {
            updateSceneDrag(event.clientX, event.clientY);
            return;
          }

          if (!state.dragging || !hasPreviewImage()) {
            return;
          }

          const dx = event.clientX - state.dragLastX;
          const dy = event.clientY - state.dragLastY;
          state.dragLastX = event.clientX;
          state.dragLastY = event.clientY;

          state.panX += dx;
          state.panY += dy;

          const rect = ui.viewport.getBoundingClientRect();
          clampPan(rect.width, rect.height);
          renderViewport();
        });

        function stopDragging(event) {
          if (state.scene.clickCandidate && event && typeof event.pointerId === "number" && state.scene.clickCandidate.pointerId === event.pointerId) {
            if (state.scene.clickCandidate.pickedId) {
              setSceneSelection(state.scene.clickCandidate.pickedId);
            }
            state.scene.clickCandidate = null;
          }

          endSceneDrag();
          endCameraLook();
          if (event && typeof event.pointerId === "number" && ui.viewport.hasPointerCapture(event.pointerId)) {
            ui.viewport.releasePointerCapture(event.pointerId);
          }
          state.dragging = false;
          ui.viewport.classList.remove("is-dragging");
        }

        ui.viewport.addEventListener("pointerup", stopDragging);
        ui.viewport.addEventListener("pointercancel", stopDragging);

        window.addEventListener("pointermove", (event) => {
          if (state.camera.lookActive) {
            updateCameraLook(event.clientX, event.clientY);
            renderViewport();
          }
          if (state.scene.drag) {
            updateSceneDrag(event.clientX, event.clientY);
          }
        });
        window.addEventListener("pointerup", () => {
          endSceneDrag();
          endCameraLook();
        });
        window.addEventListener("blur", () => {
          endCameraLook();
          endSceneDrag();
        });

        ui.viewport.addEventListener("mouseleave", () => {
          if (!state.dragging) {
            clearPixelReadout();
          }
        });

        ui.viewport.addEventListener("dblclick", () => {
          resetView();
        });
      }

      function bindEvents() {
        ui.modeSelect.addEventListener("change", () => {
          updateModeVisibility();
          syncOutputFormatFromPath();
          updateNavigationHint();
          updateLiveTuneIndicator();
          ensureStatusPolling();
          persistUserPreferences();
          closeDrawers();
        });
        ui.demoSelect.addEventListener("change", () => {
          updateDemoHint();
          updateNavigationHint();
          updateGizmoOverlay();
          ensureStatusPolling();
        });
        ui.demoPresetSelect.addEventListener("change", () => {
          applyScenePreset(ui.demoPresetSelect.value, true);
        });
        ui.backendSelect.addEventListener("change", () => {
          if (ui.backendSelect.value === "gpu") {
            loadGpuProbe(true);
            persistUserPreferences();
            return;
          }
          updateGpuWarning();
          persistUserPreferences();
        });
        ui.hoverHelpToggleBtn.addEventListener("click", () => {
          setHoverHelpEnabled(!state.hoverHelpEnabled, true);
        });

        ui.addSphereBtn.addEventListener("click", () => addSceneObject("sphere"));
        ui.addCubeBtn.addEventListener("click", () => addSceneObject("cube"));
        ui.addPlaneBtn.addEventListener("click", () => addSceneObject("plane"));
        ui.addLightBtn.addEventListener("click", () => addSceneObject("light"));
        ui.importObjBtn.addEventListener("click", () => {
          ui.objFileInput.click();
        });
        ui.clearObjBtn.addEventListener("click", () => {
          clearImportedObj();
        });
        ui.toggleObjSceneBtn.addEventListener("click", () => {
          if (!state.scene.objPath) {
            return;
          }
          setObjSceneEnabled(!state.scene.objEnabled, true);
        });
        ui.objFileInput.addEventListener("change", () => {
          const files = ui.objFileInput.files ? Array.from(ui.objFileInput.files) : [];
          if (files.length === 0) {
            return;
          }
          importObjFiles(files);
        });

        ui.sceneDuplicateBtn.addEventListener("click", duplicateSelectedSceneObject);
        ui.sceneResetBtn.addEventListener("click", resetSelectedSceneTransform);
        ui.sceneDeleteBtn.addEventListener("click", deleteSelectedSceneObject);

        ui.gizmoMoveBtn.addEventListener("click", () => setGizmoMode("move"));
        ui.gizmoRotateBtn.addEventListener("click", () => setGizmoMode("rotate"));
        ui.gizmoScaleBtn.addEventListener("click", () => setGizmoMode("scale"));
        ui.sceneAxisXBtn.addEventListener("click", () => setGizmoAxis("x"));
        ui.sceneAxisYBtn.addEventListener("click", () => setGizmoAxis("y"));
        ui.sceneAxisZBtn.addEventListener("click", () => setGizmoAxis("z"));
        ui.sceneAxisUBtn.addEventListener("click", () => setGizmoAxis("u"));

        const sceneInputs = [
          ui.scenePosX, ui.scenePosY, ui.scenePosZ,
          ui.sceneRotX, ui.sceneRotY, ui.sceneRotZ,
          ui.sceneScaleX, ui.sceneScaleY, ui.sceneScaleZ,
          ui.sceneColorR, ui.sceneColorG, ui.sceneColorB,
        ];
        for (const input of sceneInputs) {
          input.addEventListener("change", applySceneInspectorToObject);
          input.addEventListener("blur", applySceneInspectorToObject);
        }
        ui.sceneMaterialSelect.addEventListener("change", applySceneInspectorToObject);

        function bindGizmoAxisButton(button, axis) {
          button.addEventListener("pointerdown", (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (!sceneObjectById(state.scene.selectedId)) {
              return;
            }
            setGizmoAxis(axis);
            beginSceneDrag(event.clientX, event.clientY);
          });
        }
        bindGizmoAxisButton(ui.gizmoAxisX, "x");
        bindGizmoAxisButton(ui.gizmoAxisY, "y");
        bindGizmoAxisButton(ui.gizmoAxisZ, "z");
        bindGizmoAxisButton(ui.gizmoAxisU, "u");

        ui.samplesSlider.addEventListener("input", syncSliderLabels);
        ui.depthSlider.addEventListener("input", syncSliderLabels);
        ui.threadsSlider.addEventListener("input", syncSliderLabels);

        ui.liveProfileSelect.addEventListener("change", () => {
          const profile = ui.liveProfileSelect.value;
          if (profile === "custom") {
            markLiveProfileCustom();
            syncSliderLabels();
            persistUserPreferences();
            scheduleLiveSettingsPush(true);
            return;
          }
          applyLiveProfile(profile);
          persistUserPreferences();
          scheduleLiveSettingsPush(true);
        });

        ui.liveSamplesSlider.addEventListener("input", () => {
          syncSliderLabels();
          markLiveProfileCustom();
          scheduleLiveSettingsPush();
        });

        ui.liveDepthSlider.addEventListener("input", () => {
          syncSliderLabels();
          markLiveProfileCustom();
          scheduleLiveSettingsPush();
        });

        ui.liveIntervalSlider.addEventListener("input", () => {
          syncSliderLabels();
          markLiveProfileCustom();
          scheduleLiveSettingsPush();
        });

        ui.threadsSliderLive.addEventListener("input", () => {
          syncSliderLabels();
          scheduleLiveSettingsPush();
        });

        ui.widthInput.addEventListener("input", () => scheduleLiveSettingsPush());
        ui.heightInput.addEventListener("input", () => scheduleLiveSettingsPush());
        ui.widthInput.addEventListener("blur", () => scheduleLiveSettingsPush(true));
        ui.heightInput.addEventListener("blur", () => scheduleLiveSettingsPush(true));
        ui.liveOutputInput.addEventListener("blur", () => scheduleLiveSettingsPush(true));

        ui.outputFormatSelect.addEventListener("change", () => {
          applyOutputFormat(ui.outputFormatSelect.value);
          scheduleLiveSettingsPush(true);
        });

        ui.outputInput.addEventListener("blur", syncOutputFormatFromPath);
        ui.liveOutputInput.addEventListener("blur", syncOutputFormatFromPath);
        ui.liveRecentToggle.addEventListener("change", () => {
          const outputs = state.lastStatus && Array.isArray(state.lastStatus.outputs)
            ? state.lastStatus.outputs
            : state.currentOutputs;
          renderOutputs(outputs, state.lastStatus || null);
          persistUserPreferences();
          scheduleLiveSettingsPush(true);
        });
        ui.liveTuneToggle.addEventListener("change", () => {
          persistUserPreferences();
          const mode = state.lastStatus && typeof state.lastStatus.mode === "string"
            ? state.lastStatus.mode
            : ui.modeSelect.value;
          setRunningState(state.running, mode);
          if (state.running && mode === "live" && ui.liveTuneToggle.checked) {
            scheduleLiveSettingsPush(true);
          }
          updateLiveTuneIndicator();
        });

        ui.fitModeSelect.addEventListener("change", () => {
          renderViewport();
          persistUserPreferences();
        });

        ui.autoRefreshToggle.addEventListener("change", persistUserPreferences);

        ui.startBtn.addEventListener("click", startRender);
        ui.stopBtn.addEventListener("click", stopRender);
        ui.refreshBtn.addEventListener("click", () => {
          refreshStatus();
          if (hasGpuCapableDemos()) {
            loadGpuProbe(true);
          }
        });

        ui.toggleLeftSidebar.addEventListener("click", () => toggleSidebar("left"));
        ui.toggleRightSidebar.addEventListener("click", () => toggleSidebar("right"));
        ui.mobileLeftBtn.addEventListener("click", () => toggleSidebar("left"));
        ui.mobileRightBtn.addEventListener("click", () => toggleSidebar("right"));

        ui.drawerBackdrop.addEventListener("click", closeDrawers);
        ui.thumbHoverImage.addEventListener("error", hideHoverPreview);

        document.addEventListener("pointermove", (event) => {
          if (event.pointerType === "touch") {
            return;
          }
          if (!state.hoverHelpEnabled) {
            return;
          }
          if (state.camera.lookActive || state.dragging || Boolean(state.scene.drag)) {
            hideHoverHelp();
            return;
          }
          const target = hoverHelpTargetFromNode(event.target);
          if (!target) {
            hideHoverHelp();
            return;
          }
          scheduleHoverHelp(target, event.clientX, event.clientY);
        }, true);

        document.addEventListener("pointerdown", () => {
          hideHoverHelp();
        }, true);

        document.addEventListener("focusin", (event) => {
          if (!state.hoverHelpEnabled) {
            return;
          }
          const target = hoverHelpTargetFromNode(event.target);
          if (!target) {
            return;
          }
          const rect = target.getBoundingClientRect();
          const anchorX = rect.left + Math.min(Math.max(12, rect.width * 0.25), rect.width - 8);
          const anchorY = rect.bottom;
          scheduleHoverHelp(target, anchorX, anchorY);
        }, true);

        document.addEventListener("focusout", () => {
          window.setTimeout(() => {
            const active = document.activeElement;
            const target = hoverHelpTargetFromNode(active);
            if (!target) {
              hideHoverHelp();
            }
          }, 0);
        }, true);

        window.addEventListener("blur", () => {
          hideHoverHelp();
        });

        function setCameraMoveKeyState(event, pressed) {
          const key = typeof event.key === "string" ? event.key.toLowerCase() : "";
          if (!isLiveSceneNavigationEnabled()) {
            return false;
          }

          let keyName = "";
          if (key === "w") {
            keyName = "forward";
          } else if (key === "s") {
            keyName = "back";
          } else if (key === "a") {
            keyName = "left";
          } else if (key === "d") {
            keyName = "right";
          } else if (key === "q") {
            keyName = "down";
          } else if (key === "e") {
            keyName = "up";
          } else if (key === "shift") {
            keyName = "boost";
          } else {
            return false;
          }

          const viewportFocused = document.activeElement === ui.viewport;
          const viewportHovered = ui.viewport.matches(":hover");
          if (pressed && !state.camera.lookActive && !viewportFocused && !viewportHovered) {
            return false;
          }
          if (!pressed && !state.camera.keys[keyName]) {
            return false;
          }
          state.camera.keys[keyName] = pressed;

          event.preventDefault();
          if (pressed) {
            markCameraUserInput();
          }
          ensureStatusPolling();
          updateNavigationHint();
          if (!pressed && !cameraInputActive()) {
            state.camera.lastTickMs = 0;
          }
          return true;
        }

        window.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            closeDrawers();
            endCameraLook();
            hideHoverHelp();
            hideHoverPreview();
            return;
          }

          if ((event.ctrlKey || event.metaKey) && event.key === "Enter" && !event.repeat) {
            event.preventDefault();
            if (state.running) {
              stopRender();
            } else {
              startRender();
            }
            return;
          }

          if (isEditableTarget(event.target)) {
            return;
          }

          if (setCameraMoveKeyState(event, true)) {
            return;
          }

          if ((event.key === " " || event.code === "Space") && !event.repeat) {
            event.preventDefault();
            if (state.running) {
              stopRender();
            } else {
              startRender();
            }
            return;
          }

          if ((event.key === "g" || event.key === "G") && !event.repeat) {
            event.preventDefault();
            setGizmoMode("move");
            return;
          }
          if ((event.key === "r" || event.key === "R") && !event.repeat) {
            event.preventDefault();
            setGizmoMode("rotate");
            return;
          }
          if ((event.key === "s" || event.key === "S") && !event.repeat) {
            event.preventDefault();
            setGizmoMode("scale");
            return;
          }
          if ((event.key === "Delete" || event.key === "Backspace") && !event.repeat) {
            if (isSceneEditorDemo()) {
              event.preventDefault();
              deleteSelectedSceneObject();
              return;
            }
          }

          if ((event.key === "x" || event.key === "X") && !event.repeat) {
            event.preventDefault();
            setGizmoAxis("x");
            return;
          }
          if ((event.key === "y" || event.key === "Y") && !event.repeat) {
            event.preventDefault();
            setGizmoAxis("y");
            return;
          }
          if ((event.key === "z" || event.key === "Z") && !event.repeat) {
            event.preventDefault();
            setGizmoAxis("z");
            return;
          }
          if ((event.key === "u" || event.key === "U") && !event.repeat) {
            event.preventDefault();
            setGizmoAxis("u");
            return;
          }

          if ((event.key === "f" || event.key === "F") && !event.repeat) {
            event.preventDefault();
            toggleFullscreen();
          }
        });

        window.addEventListener("keyup", (event) => {
          setCameraMoveKeyState(event, false);
        });

        document.addEventListener("fullscreenchange", () => {
          ui.app.classList.toggle("is-fullscreen", Boolean(document.fullscreenElement));
          window.setTimeout(renderViewport, 30);
        });

        window.addEventListener("resize", () => {
          if (!isMobile()) {
            closeDrawers();
          }
          hideHoverHelp();
          hideHoverPreview();
          renderViewport();
        });

        ui.commandText.addEventListener("dblclick", () => {
          copyCommandPreview();
        });
      }

      function init() {
        updateGpuWarning();
        initSceneEditor();
        applyLiveProfile(state.liveProfile);
        syncSliderLabels();
        syncOutputFormatFromPath(false);
        restoreUserPreferences();
        updateDemoHint();
        updateModeVisibility();
        primeHoverHelpSources();
        setHoverHelpEnabled(state.hoverHelpEnabled, false);
        restoreSidebarState();
        restorePanelStates();
        bindPanelToggles();
        bindSliderPrecisionControls();
        bindInputPrecisionControls();
        bindViewportEvents();
        bindEvents();
        clearPixelReadout();
        updateNavigationHint();
        updateLiveTuneIndicator();
        ensureCameraLoop();
        ui.startBtn.dataset.help = "Start render. Shortcut: Space or Ctrl+Enter.";
        ui.stopBtn.dataset.help = "Stop current render. Shortcut: Space or Ctrl+Enter.";

        loadDemos()
          .then(() => {
            restoreUserPreferences();
            setHoverHelpEnabled(state.hoverHelpEnabled, false);
            updateModeVisibility();
            syncSliderLabels();
            syncOutputFormatFromPath();
            renderViewport();
            return hasGpuCapableDemos() ? loadGpuProbe(false) : null;
          })
          .finally(() => {
          refreshStatus();
          ensureStatusPolling(true);
          });
      }

      init();
    })();
  </script>
</body>
</html>
